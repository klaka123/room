<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>✦ УМНЫЙ ДИЗАЙН ИНТЕРЬЕРА</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            overflow: hidden;
            background: #1a1e2a;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Панель управления */
        .panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            z-index: 10;
        }

        .toolbar {
            background: rgba(30, 35, 45, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #4a5a7a;
            border-radius: 50px;
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            pointer-events: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .toolbar button {
            background: #2a3a5a;
            border: none;
            color: #ccddf9;
            padding: 8px 18px;
            border-radius: 40px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            border: 1px solid #4a6a8a;
        }

        .toolbar button:hover {
            background: #3a5a7a;
            color: white;
        }

        .toolbar button.active {
            background: #f0b064;
            color: #1a1e2a;
            border-color: #f0b064;
        }

        .stats {
            background: rgba(30, 35, 45, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #4a5a7a;
            border-radius: 50px;
            padding: 10px 25px;
            margin-top: 10px;
            color: #ccddf9;
            display: flex;
            gap: 30px;
            justify-content: center;
            pointer-events: auto;
            font-size: 14px;
        }

        .stats i {
            color: #f0b064;
            margin-right: 5px;
        }

        .right-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(30, 35, 45, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #4a5a7a;
            border-radius: 30px;
            padding: 20px;
            pointer-events: auto;
            color: #ccddf9;
        }

        .right-panel h3 {
            margin-bottom: 15px;
            color: #f0b064;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid #4a5a7a;
            padding-bottom: 8px;
        }

        .right-panel label {
            display: block;
            margin-top: 15px;
            font-size: 13px;
            color: #aaa;
        }

        .right-panel input, .right-panel select {
            width: 100%;
            padding: 8px 12px;
            margin-top: 4px;
            background: #1e2636;
            border: 1px solid #4a5a7a;
            border-radius: 30px;
            color: white;
        }

        .right-panel input[type="range"] {
            padding: 0;
        }

        .right-panel .checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
        }

        .right-panel .checkbox input {
            width: auto;
        }

        .hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            color: white;
            padding: 8px 20px;
            border-radius: 40px;
            font-size: 14px;
            border: 1px solid #f0b064;
            pointer-events: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div class="panel">
        <div class="toolbar">
            <button id="modePlace" class="active"><i class="fas fa-hand"></i> Предметы</button>
            <button id="modeWallDrag"><i class="fas fa-draw-polygon"></i> Стена (drag)</button>
            <button id="modeWallClick"><i class="fas fa-mouse-pointer"></i> Стена (2 клика)</button>
            <button id="modeMove"><i class="fas fa-arrows-alt"></i> Переместить</button>
            <button id="undoBtn"><i class="fas fa-undo"></i> Отмена</button>
            <button id="clearBtn"><i class="fas fa-trash"></i> Очистить</button>
        </div>
        <div class="stats">
            <span><i class="fas fa-cube"></i> Предметов: <span id="statItems">0</span></span>
            <span><i class="fas fa-tachometer-alt"></i> FPS: <span id="statFps">0</span></span>
        </div>
    </div>

    <div class="right-panel" id="itemPanel">
        <h3><i class="fas fa-couch"></i> Параметры предмета</h3>
        <label>Тип</label>
        <select id="itemType">
            <option value="cube">Куб</option>
            <option value="sphere">Сфера</option>
            <option value="cylinder">Цилиндр</option>
            <option value="chair">Стул (упрощ.)</option>
        </select>
        <label>Цвет</label>
        <input type="color" id="itemColor" value="#c47e5a">
        <label>Масштаб</label>
        <input type="range" id="itemScale" min="0.3" max="3" step="0.1" value="1">
        <label>Поворот</label>
        <input type="range" id="itemRotate" min="0" max="360" value="0">
        <div class="checkbox">
            <input type="checkbox" id="snapGrid" checked>
            <label>Привязка к сетке (0.5м)</label>
        </div>
    </div>

    <div class="right-panel" id="wallPanel" style="display:none;">
        <h3><i class="fas fa-cubes"></i> Параметры стены</h3>
        <label>Длина</label>
        <input type="range" id="wallLength" min="0.5" max="10" step="0.1" value="3">
        <label>Высота</label>
        <input type="range" id="wallHeight" min="1" max="5" step="0.1" value="2.5">
        <label>Толщина</label>
        <input type="range" id="wallThick" min="0.1" max="1" step="0.05" value="0.2">
        <label>Цвет</label>
        <input type="color" id="wallColor" value="#aaccff">
        <button id="buildWallBtn" style="width:100%; margin-top:15px; background:#f0b064; border:none; padding:10px; border-radius:30px; font-weight:bold;"><i class="fas fa-plus-circle"></i> Построить</button>
    </div>

    <div class="hint" id="hint">Режим: Предметы — клик для размещения</div>

    <canvas id="canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Инициализация сцены ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1e2a);
        scene.fog = new THREE.FogExp2(0x1a1e2a, 0.005);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 8, 20);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 3;
        controls.maxDistance = 50;
        controls.target.set(0, 2, 0);

        // --- Освещение ---
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(5, 15, 8);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 30;
        sunLight.shadow.camera.left = -10;
        sunLight.shadow.camera.right = 10;
        sunLight.shadow.camera.top = 10;
        sunLight.shadow.camera.bottom = -10;
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x40486c, 0.5);
        scene.add(ambientLight);

        const fillLight = new THREE.PointLight(0x88aaff, 0.5);
        fillLight.position.set(-4, 5, 6);
        scene.add(fillLight);

        // --- Пол и сетка ---
        const groundGeo = new THREE.CircleGeometry(50, 32);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a2e3a, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        const gridHelper = new THREE.GridHelper(30, 20, 0xf0b064, 0x3a4a6a);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // --- Состояние приложения ---
        let placedItems = [];
        let currentMode = 'place'; // 'place', 'wallDrag', 'wallClick', 'move'
        let selectedItemType = 'cube';
        let selectedItemColor = '#c47e5a';
        let selectedItemScale = 1;
        let selectedItemRotate = 0;
        let snapEnabled = true;

        // Для строительства стен
        let isDragging = false;
        let wallStart = null;
        let tempWall = null;
        let wallClickPhase = 0; // 0 - ожидание первого клика, 1 - ожидание второго
        let wallClickStart = null;

        // Для перемещения
        let movingObject = null;
        let moveOffset = new THREE.Vector3();

        // Для выделения последнего объекта (для отмены/копирования)
        let lastSelectedMesh = null;

        // --- Вспомогательные функции ---
        function snapPosition(pos, gridSize = 0.5) {
            if (!snapEnabled) return pos;
            return new THREE.Vector3(
                Math.round(pos.x / gridSize) * gridSize,
                Math.round(pos.y / gridSize) * gridSize,
                Math.round(pos.z / gridSize) * gridSize
            );
        }

        function createItem(type, color, scale = 1) {
            const mat = new THREE.MeshStandardMaterial({ color: parseInt(color.slice(1), 16) });
            let geo;
            switch(type) {
                case 'sphere': geo = new THREE.SphereGeometry(0.5, 16); break;
                case 'cylinder': geo = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); break;
                case 'chair':
                    const group = new THREE.Group();
                    const seatGeo = new THREE.BoxGeometry(0.8, 0.1, 0.8);
                    const seat = new THREE.Mesh(seatGeo, mat);
                    seat.position.y = 0.3;
                    seat.castShadow = true; seat.receiveShadow = true;
                    group.add(seat);
                    const backGeo = new THREE.BoxGeometry(0.8, 0.6, 0.1);
                    const back = new THREE.Mesh(backGeo, mat);
                    back.position.set(0, 0.8, -0.3);
                    back.castShadow = true; back.receiveShadow = true;
                    group.add(back);
                    const legGeo = new THREE.BoxGeometry(0.1, 0.3, 0.1);
                    for (let x = -0.3; x <= 0.3; x+=0.6) {
                        for (let z = -0.3; z <= 0.3; z+=0.6) {
                            const leg = new THREE.Mesh(legGeo, mat);
                            leg.position.set(x, 0.15, z);
                            leg.castShadow = true; leg.receiveShadow = true;
                            group.add(leg);
                        }
                    }
                    group.scale.set(scale, scale, scale);
                    return group;
                default: geo = new THREE.BoxGeometry(1, 1, 1);
            }
            if (type !== 'chair') {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true; mesh.receiveShadow = true;
                mesh.scale.set(scale, scale, scale);
                return mesh;
            }
        }

        // --- Обновление статистики ---
        function updateStats() {
            document.getElementById('statItems').textContent = placedItems.length;
        }

        // --- Обработчики кнопок режимов ---
        document.getElementById('modePlace').addEventListener('click', () => {
            setMode('place');
        });
        document.getElementById('modeWallDrag').addEventListener('click', () => {
            setMode('wallDrag');
        });
        document.getElementById('modeWallClick').addEventListener('click', () => {
            setMode('wallClick');
        });
        document.getElementById('modeMove').addEventListener('click', () => {
            setMode('move');
        });

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.toolbar button').forEach(btn => btn.classList.remove('active'));
            if (mode === 'place') {
                document.getElementById('modePlace').classList.add('active');
                document.getElementById('itemPanel').style.display = 'block';
                document.getElementById('wallPanel').style.display = 'none';
                document.getElementById('hint').innerHTML = 'Режим: Предметы — клик для размещения';
            } else if (mode === 'wallDrag') {
                document.getElementById('modeWallDrag').classList.add('active');
                document.getElementById('itemPanel').style.display = 'none';
                document.getElementById('wallPanel').style.display = 'block';
                document.getElementById('hint').innerHTML = 'Режим: Стена (drag) — зажмите и тяните';
            } else if (mode === 'wallClick') {
                document.getElementById('modeWallClick').classList.add('active');
                document.getElementById('itemPanel').style.display = 'none';
                document.getElementById('wallPanel').style.display = 'block';
                document.getElementById('hint').innerHTML = 'Режим: Стена (2 клика) — первый клик начало, второй конец';
                wallClickPhase = 0;
            } else if (mode === 'move') {
                document.getElementById('modeMove').classList.add('active');
                document.getElementById('itemPanel').style.display = 'block';
                document.getElementById('wallPanel').style.display = 'none';
                document.getElementById('hint').innerHTML = 'Режим: Перемещение — зажмите Ctrl+клик по предмету и перетаскивайте';
            }
            if (tempWall) scene.remove(tempWall);
            tempWall = null;
            isDragging = false;
            movingObject = null;
        }

        // --- Обновление параметров предмета ---
        document.getElementById('itemType').addEventListener('change', (e) => selectedItemType = e.target.value);
        document.getElementById('itemColor').addEventListener('input', (e) => selectedItemColor = e.target.value);
        document.getElementById('itemScale').addEventListener('input', (e) => selectedItemScale = parseFloat(e.target.value));
        document.getElementById('itemRotate').addEventListener('input', (e) => selectedItemRotate = parseFloat(e.target.value));
        document.getElementById('snapGrid').addEventListener('change', (e) => snapEnabled = e.target.checked);

        // --- Построить стену (кнопка) ---
        document.getElementById('buildWallBtn').addEventListener('click', () => {
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0; dir.normalize();
            let pos = camera.position.clone().add(dir.multiplyScalar(5));
            pos.y = 0;
            if (snapEnabled) pos = snapPosition(pos, 0.5);

            const length = parseFloat(document.getElementById('wallLength').value);
            const height = parseFloat(document.getElementById('wallHeight').value);
            const thick = parseFloat(document.getElementById('wallThick').value);
            const color = document.getElementById('wallColor').value;

            const wallMat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
            const wall = new THREE.Mesh(new THREE.BoxGeometry(thick, height, length), wallMat);
            wall.position.copy(pos);
            wall.position.y = height / 2;
            wall.castShadow = true; wall.receiveShadow = true;
            scene.add(wall);
            placedItems.push(wall);
            lastSelectedMesh = wall;
            updateStats();
        });

        // --- Отмена и очистка ---
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (placedItems.length) {
                scene.remove(placedItems.pop());
                updateStats();
            }
        });
        document.getElementById('clearBtn').addEventListener('click', () => {
            placedItems.forEach(i => scene.remove(i));
            placedItems = [];
            lastSelectedMesh = null;
            updateStats();
        });

        // --- Работа с мышью ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersect = new THREE.Vector3();

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('.toolbar, .right-panel, .stats')) return;

            mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // Режим перемещения (Ctrl + клик)
            if (currentMode === 'move' && e.ctrlKey) {
                const intersects = raycaster.intersectObjects(placedItems);
                if (intersects.length) {
                    movingObject = intersects[0].object;
                    lastSelectedMesh = movingObject;
                    // Вычисляем смещение относительно камеры? Просто запоминаем точку пересечения
                    raycaster.ray.intersectPlane(plane, moveOffset);
                    if (snapEnabled) moveOffset = snapPosition(moveOffset, 0.5);
                    isDragging = true;
                    e.preventDefault();
                }
                return;
            }

            // Режим wallDrag
            if (currentMode === 'wallDrag' && e.button === 0) {
                raycaster.ray.intersectPlane(plane, intersect);
                if (intersect) {
                    isDragging = true;
                    wallStart = snapPosition(intersect.clone(), 0.5);
                    wallStart.y = 0;
                    const thick = parseFloat(document.getElementById('wallThick').value);
                    const height = parseFloat(document.getElementById('wallHeight').value);
                    const color = document.getElementById('wallColor').value;
                    tempWall = new THREE.Mesh(
                        new THREE.BoxGeometry(thick, height, 0.1),
                        new THREE.MeshStandardMaterial({ color, transparent: true, opacity: 0.5 })
                    );
                    tempWall.castShadow = true; tempWall.receiveShadow = true;
                    scene.add(tempWall);
                }
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (e.target.closest('.toolbar, .right-panel, .stats')) return;
            mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (!raycaster.ray.intersectPlane(plane, intersect)) return;

            // Перемещение объекта
            if (currentMode === 'move' && isDragging && movingObject) {
                let pos = intersect.clone();
                if (snapEnabled) pos = snapPosition(pos, 0.5);
                movingObject.position.x = pos.x;
                movingObject.position.z = pos.z;
                movingObject.position.y = pos.y + movingObject.scale.y * 0.5;
                return;
            }

            // Строительство стены drag
            if (currentMode === 'wallDrag' && isDragging && tempWall) {
                let end = snapPosition(intersect.clone(), 0.5);
                end.y = 0;
                const delta = new THREE.Vector3().subVectors(end, wallStart);
                const length = Math.sqrt(delta.x*delta.x + delta.z*delta.z);
                const angle = Math.atan2(delta.x, delta.z);
                const height = parseFloat(document.getElementById('wallHeight').value);
                tempWall.position.x = wallStart.x + delta.x/2;
                tempWall.position.z = wallStart.z + delta.z/2;
                tempWall.position.y = height/2;
                tempWall.scale.set(1, height / (tempWall.geometry.parameters.height || 1), length);
                tempWall.rotation.y = angle;
            }

            // Предпросмотр стены при 2 кликах
            if (currentMode === 'wallClick' && wallClickPhase === 1 && tempWall) {
                let end = snapPosition(intersect.clone(), 0.5);
                end.y = 0;
                const delta = new THREE.Vector3().subVectors(end, wallClickStart);
                const length = Math.sqrt(delta.x*delta.x + delta.z*delta.z);
                const angle = Math.atan2(delta.x, delta.z);
                const height = parseFloat(document.getElementById('wallHeight').value);
                tempWall.position.x = wallClickStart.x + delta.x/2;
                tempWall.position.z = wallClickStart.z + delta.z/2;
                tempWall.position.y = height/2;
                tempWall.scale.set(1, height / (tempWall.geometry.parameters.height || 1), length);
                tempWall.rotation.y = angle;
            }
        });

        renderer.domElement.addEventListener('mouseup', (e) => {
            if (e.target.closest('.toolbar, .right-panel, .stats')) return;

            if (currentMode === 'wallDrag' && isDragging && tempWall) {
                finishWall();
                isDragging = false;
            }
            if (currentMode === 'move' && isDragging && movingObject) {
                isDragging = false;
                movingObject = null;
            }
        });

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('.toolbar, .right-panel, .stats')) return;

            mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (!raycaster.ray.intersectPlane(plane, intersect)) return;

            // Режим предметов
            if (currentMode === 'place') {
                let pos = intersect.clone();
                if (snapEnabled) pos = snapPosition(pos, 0.5);
                const item = createItem(selectedItemType, selectedItemColor, selectedItemScale);
                item.position.copy(pos);
                item.position.y += selectedItemScale * 0.5; // поднять на пол
                item.rotation.y = selectedItemRotate * Math.PI / 180;
                item.castShadow = true; item.receiveShadow = true;
                scene.add(item);
                placedItems.push(item);
                lastSelectedMesh = item;
                updateStats();
                return;
            }

            // Режим стены 2 клика
            if (currentMode === 'wallClick') {
                if (wallClickPhase === 0) {
                    wallClickStart = snapPosition(intersect.clone(), 0.5);
                    wallClickStart.y = 0;
                    const thick = parseFloat(document.getElementById('wallThick').value);
                    const height = parseFloat(document.getElementById('wallHeight').value);
                    const color = document.getElementById('wallColor').value;
                    tempWall = new THREE.Mesh(
                        new THREE.BoxGeometry(thick, height, 0.1),
                        new THREE.MeshStandardMaterial({ color, transparent: true, opacity: 0.5 })
                    );
                    tempWall.castShadow = true; tempWall.receiveShadow = true;
                    scene.add(tempWall);
                    wallClickPhase = 1;
                } else {
                    finishWall();
                    wallClickPhase = 0;
                }
            }
        });

        function finishWall() {
            if (!tempWall) return;
            const height = parseFloat(document.getElementById('wallHeight').value);
            const thick = parseFloat(document.getElementById('wallThick').value);
            const color = document.getElementById('wallColor').value;
            const length = tempWall.scale.z;
            const final = new THREE.Mesh(
                new THREE.BoxGeometry(thick, height, length),
                new THREE.MeshStandardMaterial({ color, roughness: 0.7 })
            );
            final.position.copy(tempWall.position);
            final.position.y = height/2;
            final.rotation.copy(tempWall.rotation);
            final.castShadow = true; final.receiveShadow = true;
            scene.add(final);
            placedItems.push(final);
            lastSelectedMesh = final;
            scene.remove(tempWall);
            tempWall = null;
            updateStats();
        }

        // --- FPS счётчик ---
        let lastTime = performance.now();
        let frames = 0;
        function updateFPS() {
            frames++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('statFps').textContent = frames;
                frames = 0;
                lastTime = now;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updateFPS();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.expand();
            window.Telegram.WebApp.ready();
        }

        // Инициализация
        setMode('place');
        updateStats();
    </script>
</body>
</html>
