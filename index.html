<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‚ú¶ ULTIMATE DESIGN PRO ‚Äî –ö–û–ú–ù–ê–¢–´ + –°–í–ï–¢</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:opsz,wght@14..32,300;14..32,400;14..32,500;14..32,600;14..32,700&display=swap');

        body {
            overflow: hidden;
            background: #0a0c1a;
            color: #f0f4fc;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .glass {
            background: rgba(20, 28, 42, 0.75);
            backdrop-filter: blur(20px) saturate(200%);
            border: 1px solid rgba(255, 215, 140, 0.2);
            border-radius: 36px;
            box-shadow: 0 25px 50px -30px #000;
            transition: 0.3s;
        }

        .glass:hover {
            border-color: rgba(255, 215, 140, 0.4);
        }

        .ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .top-bar {
            pointer-events: all;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 30px;
            margin-bottom: 10px;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ffd966, #ffaa66, #ff8866);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            display: flex;
            gap: 40px;
            font-size: 1rem;
        }

        .stats i {
            color: #ffd966;
            margin-right: 5px;
        }

        .main-panels {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex: 1;
            pointer-events: none;
        }

        .catalog-panel {
            pointer-events: all;
            width: 360px;
            background: rgba(20, 28, 42, 0.75);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,215,140,0.2);
            border-radius: 40px;
            padding: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .catalog-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .catalog-header h3 {
            font-size: 1.3rem;
            color: #ffd966;
        }

        .badge {
            background: rgba(255,215,140,0.2);
            border: 1px solid rgba(255,215,140,0.4);
            padding: 4px 14px;
            border-radius: 30px;
            font-size: 0.9rem;
        }

        .category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .cat-btn {
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.1);
            color: #ccc;
            padding: 6px 14px;
            border-radius: 30px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .cat-btn:hover {
            border-color: #ffd966;
            color: white;
        }

        .cat-btn.active {
            background: #ffd966;
            color: #0a0c1a;
            border-color: #ffd966;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .item-card {
            background: rgba(0,0,0,0.25);
            border-radius: 28px;
            padding: 18px 6px 12px;
            cursor: pointer;
            transition: 0.2s;
            border: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .item-card:hover {
            background: rgba(40, 60, 85, 0.6);
            transform: translateY(-3px);
            border-color: #ffd966;
        }

        .item-card.selected {
            border-color: #ffd966;
            background: rgba(255,215,140,0.15);
            box-shadow: inset 0 0 0 1px #ffd966;
        }

        .item-icon {
            font-size: 2.8rem;
            filter: drop-shadow(0 5px 10px black);
        }

        .item-name {
            font-size: 0.8rem;
            text-align: center;
            color: #ddd;
        }

        .tools-panel {
            pointer-events: all;
            width: 340px;
            background: rgba(20, 28, 42, 0.75);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,215,140,0.2);
            border-radius: 40px;
            padding: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .tools-section {
            margin-bottom: 25px;
        }

        .tools-section h4 {
            color: #ffd966;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(255,215,140,0.3);
            padding-bottom: 5px;
            font-size: 1.1rem;
        }

        .mode-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1 0 auto;
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.1);
            color: #ccc;
            padding: 8px 12px;
            border-radius: 40px;
            cursor: pointer;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.85rem;
        }

        .mode-btn:hover {
            border-color: #ffd966;
            color: white;
        }

        .mode-btn.active {
            background: #ffd966;
            color: #0a0c1a;
            border-color: #ffd966;
        }

        .control-row {
            margin-bottom: 15px;
        }

        .control-row label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 4px;
        }

        .control-row select, .control-row input {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 30px;
            color: white;
        }

        .control-row input[type="color"] {
            height: 45px;
            padding: 3px;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            color: #ccc;
        }

        .checkbox-row input {
            width: auto;
        }

        .action-btn {
            width: 100%;
            background: #ffd966;
            border: none;
            color: #0a0c1a;
            padding: 12px;
            border-radius: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            margin-top: 8px;
        }

        .action-btn:hover {
            background: #ffe082;
            transform: translateY(-2px);
        }

        .hint-bar {
            pointer-events: all;
            align-self: center;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            color: white;
            padding: 12px 40px;
            border-radius: 60px;
            border: 1px solid #ffd966;
            font-size: 1rem;
            margin-bottom: 20px;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div class="ui-container">
        <div class="top-bar glass">
            <div class="logo">‚ú¶ ULTIMATE DESIGN PRO</div>
            <div class="stats">
                <span><i class="fas fa-cube"></i> <span id="statItems">0</span></span>
                <span><i class="fas fa-tachometer-alt"></i> <span id="statFps">0</span> FPS</span>
            </div>
        </div>

        <div class="main-panels">
            <div class="catalog-panel glass">
                <div class="catalog-header">
                    <h3><i class="fas fa-couch"></i> –ö–ê–¢–ê–õ–û–ì –î–ï–ö–û–†–ê (70+)</h3>
                    <span class="badge" id="catalogCount">0</span>
                </div>
                <div class="category-tabs" id="categoryTabs"></div>
                <div class="items-grid" id="itemsGrid"></div>
            </div>

            <div class="tools-panel glass">
                <div class="tools-section">
                    <h4>–†–ï–ñ–ò–ú</h4>
                    <div class="mode-buttons">
                        <button class="mode-btn active" id="modeWall"><i class="fas fa-cubes"></i> –°—Ç–µ–Ω–∞</button>
                        <button class="mode-btn" id="modeItem"><i class="fas fa-paint-brush"></i> –î–µ–∫–æ—Ä</button>
                        <button class="mode-btn" id="modeWallDrag"><i class="fas fa-arrows-alt"></i> –°—Ç–µ–Ω–∞ Drag</button>
                        <button class="mode-btn" id="modeMove"><i class="fas fa-arrows-alt"></i> –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å</button>
                        <button class="mode-btn" id="modeRotate"><i class="fas fa-sync-alt"></i> –ü–æ–≤–µ—Ä–Ω—É—Ç—å</button>
                    </div>
                </div>

                <div class="tools-section" id="wallControls">
                    <h4>–ü–ê–†–ê–ú–ï–¢–†–´ –°–¢–ï–ù–´</h4>
                    <div class="control-row">
                        <label>–î–õ–ò–ù–ê (–º)</label>
                        <input type="range" id="wallLength" min="0.5" max="20" step="0.5" value="4">
                    </div>
                    <div class="control-row">
                        <label>–í–´–°–û–¢–ê (–º)</label>
                        <input type="range" id="wallHeight" min="1" max="15" step="0.5" value="3">
                    </div>
                    <div class="control-row">
                        <label>–¢–û–õ–©–ò–ù–ê (–º)</label>
                        <input type="range" id="wallThick" min="0.1" max="2" step="0.1" value="0.3">
                    </div>
                    <div class="control-row">
                        <label>–ú–ê–¢–ï–†–ò–ê–õ</label>
                        <select id="wallMat">
                            <option value="brick">–ö–∏—Ä–ø–∏—á</option>
                            <option value="concrete">–ë–µ—Ç–æ–Ω</option>
                            <option value="wood">–î–µ—Ä–µ–≤–æ</option>
                            <option value="stone">–ö–∞–º–µ–Ω—å</option>
                            <option value="marble">–ú—Ä–∞–º–æ—Ä</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>–¶–í–ï–¢</label>
                        <input type="color" id="wallColor" value="#c0b8b0">
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="snapGrid" checked>
                        <label>–ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ (0.5–º)</label>
                    </div>
                </div>

                <div class="tools-section" id="itemControls" style="display:none;">
                    <h4>–ü–ê–†–ê–ú–ï–¢–†–´ –î–ï–ö–û–†–ê</h4>
                    <div class="control-row">
                        <label>–ú–ê–¢–ï–†–ò–ê–õ</label>
                        <select id="itemMat">
                            <option value="wood">–î–µ—Ä–µ–≤–æ</option>
                            <option value="metal">–ú–µ—Ç–∞–ª–ª</option>
                            <option value="fabric">–¢–∫–∞–Ω—å</option>
                            <option value="glass">–°—Ç–µ–∫–ª–æ</option>
                            <option value="stone">–ö–∞–º–µ–Ω—å</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>–¶–í–ï–¢</label>
                        <input type="color" id="itemColor" value="#b09a80">
                    </div>
                    <div class="control-row">
                        <label>–ü–û–í–û–†–û–¢</label>
                        <input type="range" id="itemRotate" min="0" max="360" value="0">
                    </div>
                    <div class="control-row">
                        <label>–ú–ê–°–®–¢–ê–ë</label>
                        <input type="range" id="itemScale" min="0.5" max="3" step="0.1" value="1">
                    </div>
                    <div class="control-row">
                        <label>–í–´–°–û–¢–ê</label>
                        <input type="range" id="itemElev" min="0" max="5" step="0.1" value="0">
                    </div>
                </div>

                <div class="tools-section" id="roomControls">
                    <h4><i class="fas fa-building"></i> –°–û–ó–î–ê–¢–¨ –ö–û–ú–ù–ê–¢–£</h4>
                    <div class="control-row">
                        <label>–î–õ–ò–ù–ê (–º)</label>
                        <input type="range" id="roomLength" min="2" max="30" step="1" value="8">
                    </div>
                    <div class="control-row">
                        <label>–®–ò–†–ò–ù–ê (–º)</label>
                        <input type="range" id="roomWidth" min="2" max="30" step="1" value="6">
                    </div>
                    <div class="control-row">
                        <label>–í–´–°–û–¢–ê (–º)</label>
                        <input type="range" id="roomHeight" min="2" max="10" step="1" value="3">
                    </div>
                    <div class="control-row">
                        <label>–ú–ê–¢–ï–†–ò–ê–õ –°–¢–ï–ù</label>
                        <select id="roomWallMat">
                            <option value="brick">–ö–∏—Ä–ø–∏—á</option>
                            <option value="concrete">–ë–µ—Ç–æ–Ω</option>
                            <option value="wood">–î–µ—Ä–µ–≤–æ</option>
                            <option value="stone">–ö–∞–º–µ–Ω—å</option>
                            <option value="marble">–ú—Ä–∞–º–æ—Ä</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>–¶–í–ï–¢ –°–¢–ï–ù</label>
                        <input type="color" id="roomWallColor" value="#c0b8b0">
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="roomFloor" checked>
                        <label>–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª</label>
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="roomCeil" checked>
                        <label>–î–æ–±–∞–≤–∏—Ç—å –ø–æ—Ç–æ–ª–æ–∫</label>
                    </div>
                    <button class="action-btn" id="buildRoomBtn"><i class="fas fa-plus-circle"></i> –ü–û–°–¢–†–û–ò–¢–¨ –ö–û–ú–ù–ê–¢–£</button>
                </div>

                <div class="tools-section">
                    <h4>–ü–û–°–¢-–≠–§–§–ï–ö–¢–´</h4>
                    <div class="checkbox-row">
                        <input type="checkbox" id="fxBloom" checked>
                        <label>Bloom</label>
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="fxAO" checked>
                        <label>Ambient Occlusion</label>
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="fxSSR" checked>
                        <label>SSR (–æ—Ç—Ä–∞–∂–µ–Ω–∏—è)</label>
                    </div>
                </div>

                <button class="action-btn" id="saveBtn"><i class="fas fa-save"></i> –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                <button class="action-btn" id="loadBtn"><i class="fas fa-folder-open"></i> –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                <button class="action-btn" id="undoBtn"><i class="fas fa-undo"></i> –û—Ç–º–µ–Ω–∞</button>
                <button class="action-btn" id="clearBtn"><i class="fas fa-trash"></i> –û—á–∏—Å—Ç–∏—Ç—å</button>
                <div style="font-size:0.8rem; text-align:center; margin-top:5px; color:#aaa;">
                    <i class="fas fa-keyboard"></i> Ctrl+D –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å | Del —É–¥–∞–ª–∏—Ç—å | R –≤—Ä–∞—â–∞—Ç—å (—Ä–µ–∂–∏–º)
                </div>
            </div>
        </div>

        <div class="hint-bar" id="hint">–†–µ–∂–∏–º: –°—Ç–µ–Ω–∞ ‚Äî –∫–ª–∏–∫ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ | Ctrl+–∫–ª–∏–∫ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è | R –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è</div>
    </div>

    <canvas id="canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
        import { SSRPass } from 'three/addons/postprocessing/SSRPass.js';

        // --- –°—Ü–µ–Ω–∞ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0c1a);
        scene.fog = new THREE.FogExp2(0x0a0c1a, 0.001);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 20, 40);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputEncoding = THREE.sRGBEncoding;

        // --- –ü–æ—Å—Ç-–æ–±—Ä–∞–±–æ—Ç–∫–∞ ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.3, 0.6);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 0.8;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // Ambient Occlusion
        const saoPass = new SAOPass(scene, camera, false, true);
        saoPass.params.saoBias = 0.5;
        saoPass.params.saoIntensity = 0.5;
        saoPass.params.saoScale = 10;
        saoPass.params.saoKernelRadius = 50;
        saoPass.params.saoMinResolution = 0;
        saoPass.params.saoBlur = true;
        saoPass.params.saoBlurRadius = 4;
        saoPass.params.saoBlurStdDev = 4;
        saoPass.params.saoBlurDepthCutoff = 0.01;
        composer.addPass(saoPass);

        // SSR (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)
        const ssrPass = new SSRPass({
            renderer,
            scene,
            camera,
            width: window.innerWidth,
            height: window.innerHeight,
            selects: null,
            groundReflector: null
        });
        ssrPass.enabled = true;
        composer.addPass(ssrPass);

        // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 5;
        controls.maxDistance = 200;
        controls.target.set(0, 2, 0);

        // --- –û—Å–≤–µ—â–µ–Ω–∏–µ ---
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.3);
        sunLight.position.set(8, 25, 15);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 8192;
        sunLight.shadow.mapSize.height = 8192;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 80;
        sunLight.shadow.camera.left = -30;
        sunLight.shadow.camera.right = 30;
        sunLight.shadow.camera.top = 30;
        sunLight.shadow.camera.bottom = -30;
        scene.add(sunLight);

        const ambient = new THREE.AmbientLight(0x40486c, 0.6);
        scene.add(ambient);

        const fillLight1 = new THREE.PointLight(0xffaa88, 0.5);
        fillLight1.position.set(-8, 6, 12);
        scene.add(fillLight1);
        const fillLight2 = new THREE.PointLight(0x88aaff, 0.4);
        fillLight2.position.set(10, 5, -10);
        scene.add(fillLight2);

        // --- –ü–æ–ª –∏ —Å–µ—Ç–∫–∞ ---
        const groundGeo = new THREE.CircleGeometry(200, 64);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a2430, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        const gridHelper = new THREE.GridHelper(200, 80, 0xffd966, 0x3a4a6a);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // --- –ö–∞—Ç–∞–ª–æ–≥ (70+ –ø—Ä–µ–¥–º–µ—Ç–æ–≤) ---
        const catalog = [
            // –°—Ç—É–ª—å—è
            { id: 'chair1', name: '–ö—Ä–µ—Å–ª–æ Chester', icon: 'ü™ë', cat: 'chairs', style: 'chester', color: '#8b4513' },
            { id: 'chair2', name: '–°—Ç—É–ª Eames', icon: 'üí∫', cat: 'chairs', style: 'eames', color: '#4a5a6a' },
            { id: 'chair3', name: '–°—Ç—É–ª –õ—é–¥–æ–≤–∏–∫', icon: 'ü™ë', cat: 'chairs', style: 'louis', color: '#c49a6c' },
            { id: 'chair4', name: '–°—Ç—É–ª –í–µ–Ω—Å–∫–∏–π', icon: 'ü™ë', cat: 'chairs', style: 'vienna', color: '#d4b088' },
            { id: 'chair5', name: '–ë–∞—Ä–Ω—ã–π —Å—Ç—É–ª', icon: 'ü™ë', cat: 'chairs', style: 'bar', color: '#3a3a4a' },
            { id: 'chair6', name: '–ö—Ä–µ—Å–ª–æ-–∫–∞—á–∞–ª–∫–∞', icon: 'ü™ë', cat: 'chairs', style: 'rocking', color: '#8b5a2b' },
            // –î–∏–≤–∞–Ω—ã
            { id: 'sofa1', name: '–î–∏–≤–∞–Ω Chester', icon: 'üõãÔ∏è', cat: 'sofas', style: 'chester', color: '#8b4513' },
            { id: 'sofa2', name: '–î–∏–≤–∞–Ω Modern', icon: 'üõãÔ∏è', cat: 'sofas', style: 'modern', color: '#5a6b7a' },
            { id: 'sofa3', name: '–î–∏–≤–∞–Ω Scandi', icon: 'üõãÔ∏è', cat: 'sofas', style: 'scandi', color: '#b0aa90' },
            { id: 'sofa4', name: '–ö—É—à–µ—Ç–∫–∞', icon: 'üõãÔ∏è', cat: 'sofas', style: 'chaise', color: '#8a6d5a' },
            // –°—Ç–æ–ª—ã
            { id: 'table1', name: '–°—Ç–æ–ª –æ–±–µ–¥–µ–Ω–Ω—ã–π', icon: 'ü™ë', cat: 'tables', style: 'dining', color: '#8b5a2b' },
            { id: 'table2', name: '–ñ—É—Ä–Ω–∞–ª—å–Ω—ã–π —Å—Ç–æ–ª–∏–∫', icon: 'ü™ë', cat: 'tables', style: 'coffee', color: '#a58b6f' },
            { id: 'table3', name: '–ö–æ–Ω—Å–æ–ª—å', icon: 'ü™ë', cat: 'tables', style: 'console', color: '#7a5a3a' },
            { id: 'table4', name: '–ü–∏—Å—å–º–µ–Ω–Ω—ã–π —Å—Ç–æ–ª', icon: 'üìù', cat: 'tables', style: 'desk', color: '#5a3a2a' },
            // –®–∫–∞—Ñ—ã
            { id: 'cabinet1', name: '–°—Ç–µ–ª–ª–∞–∂', icon: 'üìö', cat: 'cabinets', style: 'shelf', color: '#8b5a2b' },
            { id: 'cabinet2', name: '–®–∫–∞—Ñ –ø–ª–∞—Ç—è–Ω–æ–π', icon: 'üö™', cat: 'cabinets', style: 'wardrobe', color: '#a0522d' },
            { id: 'cabinet3', name: '–ö–æ–º–æ–¥', icon: 'üóÑÔ∏è', cat: 'cabinets', style: 'dresser', color: '#c19a6b' },
            { id: 'cabinet4', name: '–í–∏—Ç—Ä–∏–Ω–∞', icon: 'üèõÔ∏è', cat: 'cabinets', style: 'display', color: '#d4af37' },
            // –°–≤–µ—Ç
            { id: 'lamp1', name: '–¢–æ—Ä—à–µ—Ä', icon: 'üí°', cat: 'lighting', style: 'floor', color: '#c0c0c0' },
            { id: 'lamp2', name: '–õ—é—Å—Ç—Ä–∞', icon: 'üí°', cat: 'lighting', style: 'chandelier', color: '#d4af37' },
            { id: 'lamp3', name: '–ù–∞—Å—Ç–æ–ª—å–Ω–∞—è –ª–∞–º–ø–∞', icon: 'üí°', cat: 'lighting', style: 'table', color: '#88aadd' },
            { id: 'lamp4', name: '–ë—Ä–∞', icon: 'üí°', cat: 'lighting', style: 'wall', color: '#aaaaaa' },
            { id: 'lamp5', name: '–ü–æ–¥–≤–µ—Å', icon: 'üí°', cat: 'lighting', style: 'pendant', color: '#cccccc' },
            { id: 'lamp6', name: '–¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç', icon: '‚ú®', cat: 'lighting', style: 'pointlight', color: '#ffffff' }, // –Ω–æ–≤—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Å–≤–µ—Ç–∞
            // –î–µ–∫–æ—Ä
            { id: 'vase1', name: '–í–∞–∑–∞', icon: 'üè∫', cat: 'decor', style: 'vase', color: '#5a7a9a' },
            { id: 'vase2', name: '–ö—É–≤—à–∏–Ω', icon: 'üè∫', cat: 'decor', style: 'jug', color: '#8b5a2b' },
            { id: 'mirror1', name: '–ó–µ—Ä–∫–∞–ª–æ', icon: 'ü™û', cat: 'decor', style: 'mirror', color: '#d4af37' },
            { id: 'painting1', name: '–ö–∞—Ä—Ç–∏–Ω–∞', icon: 'üñºÔ∏è', cat: 'decor', style: 'painting', color: '#9a7a5a' },
            { id: 'clock1', name: '–ß–∞—Å—ã', icon: '‚è∞', cat: 'decor', style: 'clock', color: '#8b5a2b' },
            { id: 'carpet1', name: '–ö–æ–≤—ë—Ä', icon: 'üß∂', cat: 'decor', style: 'carpet', color: '#8b1e3f' },
            { id: 'sculpture1', name: '–°–∫—É–ª—å–ø—Ç—É—Ä–∞', icon: 'üóø', cat: 'decor', style: 'sculpture', color: '#b87333' },
            { id: 'candle1', name: '–°–≤–µ—á–∞', icon: 'üïØÔ∏è', cat: 'decor', style: 'candle', color: '#f5e6d3' },
            // –†–∞—Å—Ç–µ–Ω–∏—è
            { id: 'plant1', name: '–§–∏–∫—É—Å', icon: 'üåø', cat: 'plants', style: 'ficus', color: '#2e8b57' },
            { id: 'plant2', name: '–ü–∞–ª—å–º–∞', icon: 'üå¥', cat: 'plants', style: 'palm', color: '#228b22' },
            { id: 'plant3', name: '–ö–∞–∫—Ç—É—Å', icon: 'üåµ', cat: 'plants', style: 'cactus', color: '#5f9f4f' },
            { id: 'plant4', name: '–û—Ä—Ö–∏–¥–µ—è', icon: 'üå∏', cat: 'plants', style: 'orchid', color: '#d87093' },
            { id: 'plant5', name: '–ë–æ–Ω—Å–∞–π', icon: 'üéç', cat: 'plants', style: 'bonsai', color: '#6b8e23' },
            // –¢–µ—Ö–Ω–∏–∫–∞
            { id: 'tv1', name: '–¢–µ–ª–µ–≤–∏–∑–æ—Ä', icon: 'üì∫', cat: 'tech', style: 'tv', color: '#1a1a1a' },
            { id: 'speaker1', name: '–ö–æ–ª–æ–Ω–∫–∞', icon: 'üîä', cat: 'tech', style: 'speaker', color: '#3a3a3a' },
            { id: 'laptop1', name: '–ù–æ—É—Ç–±—É–∫', icon: 'üíª', cat: 'tech', style: 'laptop', color: '#2a2a3a' },
            { id: 'fridge1', name: '–•–æ–ª–æ–¥–∏–ª—å–Ω–∏–∫', icon: 'üßä', cat: 'tech', style: 'fridge', color: '#f0f0f0' },
            { id: 'oven1', name: '–î—É—Ö–æ–≤–∫–∞', icon: 'üî•', cat: 'tech', style: 'oven', color: '#3a3a3a' },
            // –ö–Ω–∏–≥–∏
            { id: 'book1', name: '–ö–Ω–∏–≥–∏', icon: 'üìö', cat: 'books', style: 'books', color: '#8b4513' },
            { id: 'book2', name: '–≠–Ω—Ü–∏–∫–ª–æ–ø–µ–¥–∏—è', icon: 'üìñ', cat: 'books', style: 'book', color: '#5a3a2a' },
        ];

        // --- –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è —Å—Ç–µ–Ω ---
        function createWallTexture(type, baseColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 512, 512);
            if (type === 'brick') {
                ctx.fillStyle = '#8b5a2b';
                for (let y=0; y<512; y+=64) for (let x=0; x<512; x+=128) ctx.fillRect(x, y, 120, 60);
                ctx.strokeStyle = '#4a2a1a'; ctx.lineWidth=4;
                for (let x=0; x<512; x+=128) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,512); ctx.stroke(); }
            } else if (type === 'concrete') {
                for (let i=0; i<10000; i++) {
                    ctx.fillStyle = `rgba(100,100,100,${Math.random()*0.2})`;
                    ctx.beginPath(); ctx.arc(Math.random()*512, Math.random()*512, Math.random()*5, 0, 2*Math.PI); ctx.fill();
                }
            } else if (type === 'wood') {
                for (let i=0; i<30; i++) {
                    ctx.strokeStyle = '#8b5a2b'; ctx.lineWidth=8;
                    ctx.beginPath(); ctx.moveTo(0, i*20); ctx.lineTo(512, i*20+15); ctx.stroke();
                }
            } else if (type === 'marble') {
                for (let i=0; i<200; i++) {
                    ctx.strokeStyle = `rgba(128,128,128,${Math.random()*0.5})`;
                    ctx.lineWidth = Math.random()*20;
                    ctx.beginPath(); ctx.moveTo(Math.random()*512, Math.random()*512); ctx.lineTo(Math.random()*512, Math.random()*512); ctx.stroke();
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- –§—É–Ω–∫—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–µ–π (–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ) ---
        function createChairChester(color, material) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.0 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x5a3a2a, roughness: 0.7 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 0.7 });

            // –ù–æ–∂–∫–∏ —Å –∫–æ–ª–µ—Å–∏–∫–∞–º–∏
            const legGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.5, 8);
            const wheelGeo = new THREE.TorusGeometry(0.08, 0.02, 8, 16);
            for (let x = -0.6; x <= 0.6; x+=1.2) {
                for (let z = -0.6; z <= 0.6; z+=1.2) {
                    const leg = new THREE.Mesh(legGeo, darkMat);
                    leg.position.set(x, 0.25, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                    const wheel = new THREE.Mesh(wheelGeo, metalMat);
                    wheel.position.set(x, 0.1, z);
                    wheel.rotation.x = Math.PI/2;
                    wheel.castShadow = true;
                    group.add(wheel);
                }
            }
            // –°–∏–¥–µ–Ω—å–µ —Å –ø–æ–¥—É—à–∫–æ–π
            const seatBase = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.5), darkMat);
            seatBase.position.y = 0.5;
            seatBase.castShadow = true; seatBase.receiveShadow = true;
            group.add(seatBase);
            const cushion = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.2, 1.4), mat);
            cushion.position.y = 0.7;
            cushion.castShadow = true; cushion.receiveShadow = true;
            group.add(cushion);
            // –°–ø–∏–Ω–∫–∞ —Å –ø—É–≥–æ–≤–∏—Ü–∞–º–∏
            const backFrame = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 0.3), darkMat);
            backFrame.position.set(0, 1.5, -0.7);
            backFrame.castShadow = true; backFrame.receiveShadow = true;
            group.add(backFrame);
            const backCushion = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.4, 0.2), mat);
            backCushion.position.set(0, 1.5, -0.6);
            backCushion.castShadow = true; backCushion.receiveShadow = true;
            group.add(backCushion);
            for (let i = -0.6; i <= 0.6; i+=0.6) {
                for (let j = 1.0; j <= 1.8; j+=0.4) {
                    const btn = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8), metalMat);
                    btn.position.set(i, j, -0.55);
                    btn.castShadow = true;
                    group.add(btn);
                }
            }
            // –ü–æ–¥–ª–æ–∫–æ—Ç–Ω–∏–∫–∏
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 1.5), darkMat);
            arm.position.set(-0.95, 1.0, 0);
            arm.castShadow = true; arm.receiveShadow = true;
            group.add(arm);
            const arm2 = arm.clone(); arm2.position.set(0.95, 1.0, 0); group.add(arm2);
            return group;
        }

        function createTableDining(color, material) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
            const legMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });
            const top = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.1, 1.2), mat);
            top.position.y = 0.9;
            top.castShadow = true; top.receiveShadow = true;
            group.add(top);
            const legGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.8, 8);
            for (let x = -0.8; x <= 0.8; x+=1.6) {
                for (let z = -0.5; z <= 0.5; z+=1.0) {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set(x, 0.4, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                }
            }
            return group;
        }

        function createLampFloor(color, material) {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.3, metalness: 0.8 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.2, 8), metalMat);
            base.position.y = 0.1; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 2.5, 8), metalMat);
            pole.position.y = 1.35; pole.castShadow = true; pole.receiveShadow = true;
            group.add(pole);
            const shade = new THREE.Mesh(new THREE.ConeGeometry(0.6, 0.7, 8), new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.2 }));
            shade.position.y = 2.5; shade.castShadow = true; shade.receiveShadow = true;
            group.add(shade);
            const light = new THREE.PointLight(0xffeedd, 1, 5);
            light.position.y = 2.2; group.add(light);
            return group;
        }

        function createPlant(color, material) {
            const group = new THREE.Group();
            const potMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const leafMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.5, 8), potMat);
            pot.position.y = 0.25; pot.castShadow = true; pot.receiveShadow = true;
            group.add(pot);
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 1.5, 6), potMat);
            stem.position.y = 1.0; stem.castShadow = true; stem.receiveShadow = true;
            group.add(stem);
            for (let i=0; i<6; i++) {
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.6, 5), leafMat);
                leaf.position.set(Math.cos(i*1.05)*0.6, 1.6, Math.sin(i*1.05)*0.6);
                leaf.rotation.x = 0.2; leaf.rotation.y = i; leaf.castShadow = true;
                group.add(leaf);
            }
            group.userData = { speed: 0.5 + Math.random()*0.5 };
            return group;
        }

        function createPointLightItem(color, material) {
            // –°–æ–∑–¥–∞—ë–º –≤–∏–¥–∏–º—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Å–≤–µ—Ç–∞ (—Å—Ñ–µ—Ä–∞ + —Å–≤–µ—Ç)
            const group = new THREE.Group();
            const bulbMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, emissive: 0xffeedd, emissiveIntensity: 0.8 });
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16), bulbMat);
            sphere.castShadow = true; sphere.receiveShadow = true;
            group.add(sphere);
            const light = new THREE.PointLight(parseInt(color.slice(1), 16), 2, 10);
            group.add(light);
            return group;
        }

        function createGenericItem(style, color, material) {
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
            const geo = new THREE.BoxGeometry(1,1,1);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            return mesh;
        }

        function createItemFromCatalog(item, color, material) {
            const colorHex = parseInt(color.slice(1), 16);
            if (item.style === 'pointlight') {
                return createPointLightItem(color, material);
            }
            switch(item.style) {
                case 'chester': return createChairChester(colorHex, material);
                case 'dining': return createTableDining(colorHex, material);
                case 'floor': return createLampFloor(colorHex, material);
                case 'ficus': case 'palm': case 'cactus': case 'orchid': case 'bonsai': return createPlant(colorHex, material);
                default: return createGenericItem(item.style, colorHex, material);
            }
        }

        // --- UI ---
        function loadCatalog() {
            const grid = document.getElementById('itemsGrid');
            const catDiv = document.getElementById('categoryTabs');
            const cats = new Set(catalog.map(i => i.cat));
            const catNames = {
                chairs: '–°—Ç—É–ª—å—è', sofas: '–î–∏–≤–∞–Ω—ã', tables: '–°—Ç–æ–ª—ã', lighting: '–°–≤–µ—Ç',
                cabinets: '–®–∫–∞—Ñ—ã', decor: '–î–µ–∫–æ—Ä', plants: '–†–∞—Å—Ç–µ–Ω–∏—è', tech: '–¢–µ—Ö–Ω–∏–∫–∞', books: '–ö–Ω–∏–≥–∏'
            };

            const allBtn = document.createElement('button');
            allBtn.className = 'cat-btn active';
            allBtn.dataset.cat = 'all';
            allBtn.textContent = '–í–°–Å';
            allBtn.addEventListener('click', () => filterCategory('all', allBtn));
            catDiv.appendChild(allBtn);

            cats.forEach(cat => {
                const btn = document.createElement('button');
                btn.className = 'cat-btn';
                btn.dataset.cat = cat;
                btn.textContent = catNames[cat] || cat;
                btn.addEventListener('click', () => filterCategory(cat, btn));
                catDiv.appendChild(btn);
            });

            catalog.forEach(item => {
                const card = document.createElement('div');
                card.className = 'item-card';
                card.dataset.id = item.id;
                card.dataset.cat = item.cat;
                card.innerHTML = `<div class="item-icon">${item.icon}</div><div class="item-name">${item.name}</div>`;
                card.addEventListener('click', () => {
                    document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedItem = item;
                });
                grid.appendChild(card);
            });
            document.getElementById('catalogCount').textContent = catalog.length;
        }

        function filterCategory(cat, activeBtn) {
            document.querySelectorAll('.cat-btn').forEach(b => b.classList.remove('active'));
            activeBtn.classList.add('active');
            document.querySelectorAll('.item-card').forEach(card => {
                if (cat === 'all' || card.dataset.cat === cat) card.style.display = 'flex';
                else card.style.display = 'none';
            });
        }

        // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ ---
        let placedItems = [];
        let currentMode = 'wall'; // wall, item, wallDrag, move, rotate
        let wallMat = 'brick';
        let wallColor = '#c0b8b0';
        let wallLength = 4, wallHeight = 3, wallThick = 0.3;
        let itemMat = 'wood', itemColor = '#b09a80', itemRotate = 0, itemScale = 1, itemElev = 0;
        let snapEnabled = true;
        let selectedItem = catalog[0];

        // –î–ª—è Drag-—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
        let isDragging = false;
        let dragStart = null;
        let tempWall = null;

        // –î–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è/–≤—Ä–∞—â–µ–Ω–∏—è
        let movingObject = null;
        let rotatingObject = null;
        let lastSelectedMesh = null;
        let moveOffset = new THREE.Vector3();

        // --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ ---
        document.getElementById('wallLength').addEventListener('input', (e) => wallLength = parseFloat(e.target.value));
        document.getElementById('wallHeight').addEventListener('input', (e) => wallHeight = parseFloat(e.target.value));
        document.getElementById('wallThick').addEventListener('input', (e) => wallThick = parseFloat(e.target.value));
        document.getElementById('wallMat').addEventListener('change', (e) => wallMat = e.target.value);
        document.getElementById('wallColor').addEventListener('input', (e) => wallColor = e.target.value);
        document.getElementById('itemMat').addEventListener('change', (e) => itemMat = e.target.value);
        document.getElementById('itemColor').addEventListener('input', (e) => itemColor = e.target.value);
        document.getElementById('itemRotate').addEventListener('input', (e) => itemRotate = parseFloat(e.target.value));
        document.getElementById('itemScale').addEventListener('input', (e) => itemScale = parseFloat(e.target.value));
        document.getElementById('itemElev').addEventListener('input', (e) => itemElev = parseFloat(e.target.value));
        document.getElementById('snapGrid').addEventListener('change', (e) => snapEnabled = e.target.checked);

        // –ü–æ—Å—Ç-—ç—Ñ—Ñ–µ–∫—Ç—ã —á–µ–∫–±–æ–∫—Å—ã
        document.getElementById('fxBloom').addEventListener('change', (e) => bloomPass.enabled = e.target.checked);
        document.getElementById('fxAO').addEventListener('change', (e) => saoPass.enabled = e.target.checked);
        document.getElementById('fxSSR').addEventListener('change', (e) => ssrPass.enabled = e.target.checked);

        // --- –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–æ–≤ ---
        const modeWall = document.getElementById('modeWall');
        const modeItem = document.getElementById('modeItem');
        const modeWallDrag = document.getElementById('modeWallDrag');
        const modeMove = document.getElementById('modeMove');
        const modeRotate = document.getElementById('modeRotate');

        modeWall.addEventListener('click', () => setMode('wall'));
        modeItem.addEventListener('click', () => setMode('item'));
        modeWallDrag.addEventListener('click', () => setMode('wallDrag'));
        modeMove.addEventListener('click', () => setMode('move'));
        modeRotate.addEventListener('click', () => setMode('rotate'));

        function setMode(mode) {
            currentMode = mode;
            [modeWall, modeItem, modeWallDrag, modeMove, modeRotate].forEach(b => b.classList.remove('active'));
            if (mode === 'wall') {
                modeWall.classList.add('active');
                document.getElementById('wallControls').style.display = 'block';
                document.getElementById('itemControls').style.display = 'none';
                document.getElementById('hint').innerHTML = '–†–µ–∂–∏–º: –°—Ç–µ–Ω–∞ ‚Äî –∫–ª–∏–∫ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏';
            } else if (mode === 'item') {
                modeItem.classList.add('active');
                document.getElementById('wallControls').style.display = 'none';
                document.getElementById('itemControls').style.display = 'block';
                document.getElementById('hint').innerHTML = '–†–µ–∂–∏–º: –î–µ–∫–æ—Ä ‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç –∏ –∫–ª–∏–∫–Ω–∏—Ç–µ';
            } else if (mode === 'wallDrag') {
                modeWallDrag.classList.add('active');
                document.getElementById('wallControls').style.display = 'block';
                document.getElementById('itemControls').style.display = 'none';
                document.getElementById('hint').innerHTML = '–†–µ–∂–∏–º: –°—Ç–µ–Ω–∞ Drag ‚Äî –∑–∞–∂–º–∏—Ç–µ –∏ —Ç—è–Ω–∏—Ç–µ';
            } else if (mode === 'move') {
                modeMove.classList.add('active');
                document.getElementById('wallControls').style.display = 'none';
                document.getElementById('itemControls').style.display = 'block';
                document.getElementById('hint').innerHTML = '–†–µ–∂–∏–º: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ ‚Äî –∑–∞–∂–º–∏—Ç–µ Ctrl+–∫–ª–∏–∫ –ø–æ –ø—Ä–µ–¥–º–µ—Ç—É';
            } else if (mode === 'rotate') {
                modeRotate.classList.add('active');
                document.getElementById('wallControls').style.display = 'none';
                document.getElementById('itemControls').style.display = 'block';
                document.getElementById('hint').innerHTML = '–†–µ–∂–∏–º: –í—Ä–∞—â–µ–Ω–∏–µ ‚Äî –∑–∞–∂–º–∏—Ç–µ Ctrl+–∫–ª–∏–∫ –ø–æ –ø—Ä–µ–¥–º–µ—Ç—É –∏ –¥–≤–∏–≥–∞–π—Ç–µ –º—ã—à—å';
            }
            if (tempWall) scene.remove(tempWall);
            tempWall = null;
            isDragging = false;
            movingObject = null;
            rotatingObject = null;
        }

        // --- –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã ---
        document.getElementById('buildRoomBtn').addEventListener('click', () => {
            const len = parseFloat(document.getElementById('roomLength').value);
            const wid = parseFloat(document.getElementById('roomWidth').value);
            const h = parseFloat(document.getElementById('roomHeight').value);
            const wallMat = document.getElementById('roomWallMat').value;
            const wallColor = document.getElementById('roomWallColor').value;
            const addFloor = document.getElementById('roomFloor').checked;
            const addCeil = document.getElementById('roomCeil').checked;

            const tex = createWallTexture(wallMat, wallColor);
            const wallMaterial = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.7 });

            // –°—Ç–µ–Ω—ã (—á–µ—Ç—ã—Ä–µ —à—Ç—É–∫–∏)
            const thick = 0.3; // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ç–æ–ª—â–∏–Ω–∞ –¥–ª—è —Å—Ç–µ–Ω –∫–æ–º–Ω–∞—Ç—ã

            // –ü–µ—Ä–µ–¥–Ω—è—è —Å—Ç–µ–Ω–∞
            const front = new THREE.Mesh(new THREE.BoxGeometry(len, h, thick), wallMaterial);
            front.position.set(0, h/2, wid/2);
            front.castShadow = true; front.receiveShadow = true;
            scene.add(front);
            placedItems.push(front);

            // –ó–∞–¥–Ω—è—è —Å—Ç–µ–Ω–∞
            const back = front.clone();
            back.position.set(0, h/2, -wid/2);
            scene.add(back);
            placedItems.push(back);

            // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞
            const left = new THREE.Mesh(new THREE.BoxGeometry(thick, h, wid), wallMaterial);
            left.position.set(-len/2, h/2, 0);
            left.castShadow = true; left.receiveShadow = true;
            scene.add(left);
            placedItems.push(left);

            // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞
            const right = left.clone();
            right.position.set(len/2, h/2, 0);
            scene.add(right);
            placedItems.push(right);

            // –ü–æ–ª
            if (addFloor) {
                const floorMat = new THREE.MeshStandardMaterial({ color: 0x2a2e3a, roughness: 0.8 });
                const floor = new THREE.Mesh(new THREE.BoxGeometry(len, 0.1, wid), floorMat);
                floor.position.set(0, 0, 0);
                floor.castShadow = true; floor.receiveShadow = true;
                scene.add(floor);
                placedItems.push(floor);
            }

            // –ü–æ—Ç–æ–ª–æ–∫
            if (addCeil) {
                const ceilMat = new THREE.MeshStandardMaterial({ color: 0x3a3f4a, roughness: 0.9 });
                const ceil = new THREE.Mesh(new THREE.BoxGeometry(len, 0.1, wid), ceilMat);
                ceil.position.set(0, h, 0);
                ceil.castShadow = true; ceil.receiveShadow = true;
                scene.add(ceil);
                placedItems.push(ceil);
            }

            updateStats();
        });

        // --- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ/–∑–∞–≥—Ä—É–∑–∫–∞ ---
        document.getElementById('saveBtn').addEventListener('click', () => {
            const data = placedItems.map(item => ({
                position: [item.position.x, item.position.y, item.position.z],
                rotation: [item.rotation.x, item.rotation.y, item.rotation.z],
                scale: [item.scale.x, item.scale.y, item.scale.z],
                color: item.material?.color?.getHex() || 0xffffff
            }));
            localStorage.setItem('design_scene', JSON.stringify(data));
            alert('–°—Ü–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞');
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            const data = JSON.parse(localStorage.getItem('design_scene'));
            if (!data) return;
            placedItems.forEach(i => scene.remove(i));
            placedItems = [];
            data.forEach(d => {
                const mat = new THREE.MeshStandardMaterial({ color: d.color });
                const geo = new THREE.BoxGeometry(1,1,1);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(d.position[0], d.position[1], d.position[2]);
                mesh.rotation.set(d.rotation[0], d.rotation[1], d.rotation[2]);
                mesh.scale.set(d.scale[0], d.scale[1], d.scale[2]);
                mesh.castShadow = true; mesh.receiveShadow = true;
                scene.add(mesh);
                placedItems.push(mesh);
            });
            updateStats();
        });

        // --- –û—Ç–º–µ–Ω–∞ –∏ –æ—á–∏—Å—Ç–∫–∞ ---
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (placedItems.length) {
                scene.remove(placedItems.pop());
                updateStats();
            }
        });
        document.getElementById('clearBtn').addEventListener('click', () => {
            placedItems.forEach(i => scene.remove(i));
            placedItems = [];
            lastSelectedMesh = null;
            updateStats();
        });

        // --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ ---
        document.addEventListener('keydown', (e) => {
            if (e.target.closest('input,select')) return;
            if (e.key === 'Delete' || e.key === 'Del') {
                if (lastSelectedMesh) {
                    scene.remove(lastSelectedMesh);
                    placedItems = placedItems.filter(i => i !== lastSelectedMesh);
                    lastSelectedMesh = null;
                    updateStats();
                }
            }
            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                if (lastSelectedMesh) {
                    const clone = lastSelectedMesh.clone();
                    clone.position.x += 1;
                    scene.add(clone);
                    placedItems.push(clone);
                    lastSelectedMesh = clone;
                    updateStats();
                }
            }
        });

        // --- –ú—ã—à—å ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersect = new THREE.Vector3();

        function snapPosition(pos, gridSize = 0.5) {
            if (!snapEnabled) return pos;
            return new THREE.Vector3(
                Math.round(pos.x / gridSize) * gridSize,
                Math.round(pos.y / gridSize) * gridSize,
                Math.round(pos.z / gridSize) * gridSize
            );
        }

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('.ui-container')) return;
            mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // –†–µ–∂–∏–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è/–≤—Ä–∞—â–µ–Ω–∏—è (Ctrl+–∫–ª–∏–∫)
            if ((currentMode === 'move' || currentMode === 'rotate') && e.ctrlKey) {
                const intersects = raycaster.intersectObjects(placedItems);
                if (intersects.length) {
                    if (currentMode === 'move') {
                        movingObject = intersects[0].object;
                        lastSelectedMesh = movingObject;
                        isDragging = true;
                        raycaster.ray.intersectPlane(plane, moveOffset);
                        if (snapEnabled) moveOffset = snapPosition(moveOffset);
                    } else if (currentMode === 'rotate') {
                        rotatingObject = intersects[0].object;
                        lastSelectedMesh = rotatingObject;
                        isDragging = true;
                    }
                    e.preventDefault();
                }
                return;
            }

            // –†–µ–∂–∏–º wallDrag
            if (currentMode === 'wallDrag' && e.button === 0) {
                raycaster.ray.intersectPlane(plane, intersect);
                if (intersect) {
                    isDragging = true;
                    dragStart = snapPosition(intersect.clone(), 0.5);
                    dragStart.y = 0;
                    const texture = createWallTexture(wallMat, wallColor);
                    const mat = new THREE.MeshStandardMaterial({ map: texture, transparent: true, opacity: 0.5, roughness: 0.7 });
                    tempWall = new THREE.Mesh(new THREE.BoxGeometry(wallThick, wallHeight, 0.1), mat);
                    tempWall.castShadow = true; tempWall.receiveShadow = true;
                    scene.add(tempWall);
                }
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (e.target.closest('.ui-container')) return;
            if (!isDragging) return;

            mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if (!raycaster.ray.intersectPlane(plane, intersect)) return;

            if (currentMode === 'wallDrag' && tempWall) {
                let end = snapPosition(intersect.clone(), 0.5);
                end.y = 0;
                const delta = new THREE.Vector3().subVectors(end, dragStart);
                const length = Math.sqrt(delta.x*delta.x + delta.z*delta.z);
                const angle = Math.atan2(delta.x, delta.z);
                tempWall.position.x = dragStart.x + delta.x/2;
                tempWall.position.z = dragStart.z + delta.z/2;
                tempWall.position.y = wallHeight/2;
                tempWall.scale.set(1, wallHeight / (tempWall.geometry.parameters.height || 1), length);
                tempWall.rotation.y = angle;
            } else if (currentMode === 'move' && movingObject) {
                let pos = intersect.clone();
                if (snapEnabled) pos = snapPosition(pos, 0.5);
                movingObject.position.x = pos.x;
                movingObject.position.z = pos.z;
                movingObject.position.y = pos.y + movingObject.scale.y * 0.5;
            } else if (currentMode === 'rotate' && rotatingObject) {
                // –í—Ä–∞—â–∞–µ–º –≤–æ–∫—Ä—É–≥ Y –ø–æ –¥–≤–∏–∂–µ–Ω–∏—é –º—ã—à–∏ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                rotatingObject.rotation.y += mouse.x * 0.1;
            }
        });

        renderer.domElement.addEventListener('mouseup', (e) => {
            if (e.target.closest('.ui-container')) return;
            if (!isDragging) return;

            if (currentMode === 'wallDrag' && tempWall) {
                const length = tempWall.scale.z;
                const texture = createWallTexture(wallMat, wallColor);
                const mat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7 });
                const finalWall = new THREE.Mesh(new THREE.BoxGeometry(wallThick, wallHeight, length), mat);
                finalWall.position.copy(tempWall.position);
                finalWall.position.y = wallHeight/2;
                finalWall.rotation.copy(tempWall.rotation);
                finalWall.castShadow = true; finalWall.receiveShadow = true;
                scene.add(finalWall);
                placedItems.push(finalWall);
                lastSelectedMesh = finalWall;
                scene.remove(tempWall);
                tempWall = null;
                updateStats();
            }
            movingObject = null;
            rotatingObject = null;
            isDragging = false;
        });

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('.ui-container')) return;

            mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if (!raycaster.ray.intersectPlane(plane, intersect)) return;

            let pos = intersect.clone();
            if (snapEnabled) pos = snapPosition(pos, 0.5);
            pos.y = 0;

            if (currentMode === 'wall') {
                const texture = createWallTexture(wallMat, wallColor);
                const mat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7 });
                const wall = new THREE.Mesh(new THREE.BoxGeometry(wallThick, wallHeight, wallLength), mat);
                wall.position.copy(pos);
                wall.position.y = wallHeight/2;
                wall.castShadow = true; wall.receiveShadow = true;
                scene.add(wall);
                placedItems.push(wall);
                lastSelectedMesh = wall;
            } else if (currentMode === 'item') {
                const item = createItemFromCatalog(selectedItem, itemColor, itemMat);
                item.position.copy(pos);
                item.position.y = itemElev + 0.5;
                item.scale.set(itemScale, itemScale, itemScale);
                item.rotation.y = itemRotate * Math.PI / 180;
                scene.add(item);
                placedItems.push(item);
                lastSelectedMesh = item;
            }
            updateStats();
        });

        // --- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –∞–Ω–∏–º–∞—Ü–∏—è ---
        function updateStats() {
            document.getElementById('statItems').textContent = placedItems.length;
        }

        let lastTime = performance.now();
        let frames = 0;
        function updateFPS() {
            frames++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('statFps').textContent = frames;
                frames = 0;
                lastTime = now;
            }
        }

        function animatePlants() {
            placedItems.forEach(item => {
                if (item.userData && item.userData.speed) {
                    item.rotation.z = Math.sin(Date.now() * 0.001 * item.userData.speed) * 0.02;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            animatePlants();
            controls.update();
            composer.render();
            updateFPS();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.expand();
            window.Telegram.WebApp.ready();
        }

        loadCatalog();
        animate();
    </script>
</body>
</html>
