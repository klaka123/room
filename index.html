<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>✦ ПРОСТОЙ ДИЗАЙН ИНТЕРЬЕРА (РАБОЧАЯ ВЕРСИЯ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30,30,30,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 40px;
            display: flex;
            gap: 15px;
            backdrop-filter: blur(5px);
            z-index: 100;
            pointer-events: all;
        }
        .btn {
            background: #444;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: 0.2s;
        }
        .btn:hover {
            background: #666;
        }
        .btn.active {
            background: #f0a050;
            color: black;
        }
        #panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30,30,30,0.8);
            backdrop-filter: blur(5px);
            color: white;
            padding: 20px;
            border-radius: 16px;
            width: 260px;
            z-index: 100;
            pointer-events: all;
        }
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        .color-input {
            width: 100%;
            height: 40px;
            margin: 5px 0 15px;
            border: none;
            background: transparent;
        }
        .checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="info">
        <div>Объектов: <span id="objCount">0</span></div>
        <div>Режим: <span id="modeDisplay">Стена</span></div>
    </div>
    <div id="controls">
        <button class="btn active" id="modeWall">Стена</button>
        <button class="btn" id="modeItem">Предмет</button>
        <button class="btn" id="modeMove">Переместить</button>
        <button class="btn" id="modeRotate">Повернуть</button>
        <button class="btn" id="undo">Отмена</button>
        <button class="btn" id="clear">Очистить</button>
    </div>
    <div id="panel">
        <h3>Параметры</h3>
        <div id="wallParams">
            <label>Длина</label>
            <input type="range" id="wallLength" min="0.5" max="10" step="0.1" value="2" class="slider">
            <label>Высота</label>
            <input type="range" id="wallHeight" min="0.5" max="5" step="0.1" value="2" class="slider">
            <label>Толщина</label>
            <input type="range" id="wallThick" min="0.1" max="1" step="0.05" value="0.2" class="slider">
            <label>Цвет</label>
            <input type="color" id="wallColor" value="#aaccff" class="color-input">
        </div>
        <div id="itemParams" style="display:none;">
            <label>Форма</label>
            <select id="itemShape">
                <option value="box">Куб</option>
                <option value="sphere">Сфера</option>
                <option value="cylinder">Цилиндр</option>
            </select>
            <label>Цвет</label>
            <input type="color" id="itemColor" value="#c47e5a" class="color-input">
            <label>Масштаб</label>
            <input type="range" id="itemScale" min="0.3" max="3" step="0.1" value="1" class="slider">
            <label>Поворот</label>
            <input type="range" id="itemRotate" min="0" max="360" value="0" class="slider">
        </div>
        <div class="checkbox">
            <input type="checkbox" id="snapGrid" checked>
            <label>Привязка к сетке (0.5 м)</label>
        </div>
        <button class="btn" id="copyBtn" style="width:100%; margin-top:10px;">Копировать (Ctrl+D)</button>
    </div>

    <canvas id="canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Инициализация сцены ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x11131f);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 8, 20);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 3;
        controls.maxDistance = 50;
        controls.target.set(0, 2, 0);

        // --- Освещение ---
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(5, 15, 8);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 30;
        sunLight.shadow.camera.left = -10;
        sunLight.shadow.camera.right = 10;
        sunLight.shadow.camera.top = 10;
        sunLight.shadow.camera.bottom = -10;
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x40486c, 0.6);
        scene.add(ambientLight);

        // --- Пол и сетка ---
        const groundGeo = new THREE.CircleGeometry(50, 32);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a2e3a, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        const gridHelper = new THREE.GridHelper(30, 20, 0xffaa66, 0x3a4a6a);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // --- Состояние ---
        let placedObjects = [];
        let currentMode = 'wall'; // wall, item, move, rotate
        let selectedObject = null; // для перемещения/вращения/копирования
        let isDragging = false;
        let dragStartPos = new THREE.Vector3();
        let initialObjectPos = new THREE.Vector3();
        let initialMouse = new THREE.Vector2();

        // Параметры
        let wallLength = 2, wallHeight = 2, wallThick = 0.2;
        let wallColor = '#aaccff';
        let itemShape = 'box', itemColor = '#c47e5a', itemScale = 1, itemRotate = 0;
        let snapEnabled = true;

        // --- Обновление UI ---
        function updateUI() {
            document.getElementById('objCount').innerText = placedObjects.length;
            document.getElementById('modeDisplay').innerText = 
                currentMode === 'wall' ? 'Стена' :
                currentMode === 'item' ? 'Предмет' :
                currentMode === 'move' ? 'Перемещение' : 'Поворот';
            
            document.getElementById('modeWall').classList.toggle('active', currentMode === 'wall');
            document.getElementById('modeItem').classList.toggle('active', currentMode === 'item');
            document.getElementById('modeMove').classList.toggle('active', currentMode === 'move');
            document.getElementById('modeRotate').classList.toggle('active', currentMode === 'rotate');

            document.getElementById('wallParams').style.display = currentMode === 'wall' ? 'block' : 'none';
            document.getElementById('itemParams').style.display = currentMode === 'item' ? 'block' : 'none';
        }

        // --- Привязка к сетке ---
        function snap(pos, grid = 0.5) {
            if (!snapEnabled) return pos;
            return new THREE.Vector3(
                Math.round(pos.x / grid) * grid,
                Math.round(pos.y / grid) * grid,
                Math.round(pos.z / grid) * grid
            );
        }

        // --- Создание объектов ---
        function createWall() {
            const color = parseInt(wallColor.slice(1), 16);
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
            const geo = new THREE.BoxGeometry(wallThick, wallHeight, wallLength);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createItem() {
            const color = parseInt(itemColor.slice(1), 16);
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.5 });
            let geo;
            if (itemShape === 'sphere') geo = new THREE.SphereGeometry(0.5, 16);
            else if (itemShape === 'cylinder') geo = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            else geo = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.scale.set(itemScale, itemScale, itemScale);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // --- Получение позиции под мышью ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();

        function getIntersect(event) {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                return intersectPoint.clone();
            }
            return null;
        }

        // --- Обработчики событий ---
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // только левая кнопка
            if (e.target.closest('#controls, #panel')) return;

            const point = getIntersect(e);
            if (!point) return;

            if (currentMode === 'move' && e.ctrlKey) {
                // Выбор объекта для перемещения
                const pos = snap(point);
                raycaster.ray.intersectPlane(plane, pos);
                const intersects = raycaster.intersectObjects(placedObjects);
                if (intersects.length > 0) {
                    selectedObject = intersects[0].object;
                    isDragging = true;
                    initialObjectPos.copy(selectedObject.position);
                    dragStartPos.copy(snap(point));
                    e.preventDefault();
                }
            } else if (currentMode === 'rotate' && e.ctrlKey) {
                // Выбор объекта для вращения
                const intersects = raycaster.intersectObjects(placedObjects);
                if (intersects.length > 0) {
                    selectedObject = intersects[0].object;
                    isDragging = true;
                    initialMouse.set(mouse.x, mouse.y);
                    e.preventDefault();
                }
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const point = getIntersect(e);
            if (!point) return;

            if (currentMode === 'move' && selectedObject) {
                let target = snap(point);
                target.y = target.y + selectedObject.scale.y * 0.5; // поднимаем на пол
                selectedObject.position.copy(target);
            } else if (currentMode === 'rotate' && selectedObject) {
                // вращаем по горизонтальному движению мыши
                const delta = mouse.x - initialMouse.x;
                selectedObject.rotation.y += delta * 0.5;
                initialMouse.set(mouse.x, mouse.y);
            }
        });

        renderer.domElement.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                selectedObject = null;
            }
        });

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('#controls, #panel')) return;
            if (e.ctrlKey) return; // при зажатом Ctrl обрабатываем перемещение/вращение отдельно

            const point = getIntersect(e);
            if (!point) return;

            let pos = snap(point);
            pos.y = 0; // всегда ставим на пол (потом поднимем)

            if (currentMode === 'wall') {
                const wall = createWall();
                wall.position.copy(pos);
                wall.position.y = wallHeight / 2;
                scene.add(wall);
                placedObjects.push(wall);
            } else if (currentMode === 'item') {
                const item = createItem();
                item.position.copy(pos);
                item.position.y = itemScale * 0.5; // поднимаем
                item.rotation.y = itemRotate * Math.PI / 180;
                scene.add(item);
                placedObjects.push(item);
            }
            updateUI();
        });

        // --- Клавиатура ---
        document.addEventListener('keydown', (e) => {
            if (e.target.closest('input,select')) return;

            if (e.key === 'Delete' || e.key === 'Del') {
                if (selectedObject) {
                    const idx = placedObjects.indexOf(selectedObject);
                    if (idx !== -1) {
                        scene.remove(selectedObject);
                        placedObjects.splice(idx, 1);
                        selectedObject = null;
                        updateUI();
                    }
                }
            }

            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                if (selectedObject) {
                    const clone = selectedObject.clone();
                    clone.position.x += 1;
                    clone.position.y += 1; // немного выше, чтобы не перекрывалось
                    scene.add(clone);
                    placedObjects.push(clone);
                    selectedObject = clone;
                    updateUI();
                }
            }
        });

        // --- Кнопки интерфейса ---
        document.getElementById('modeWall').addEventListener('click', () => {
            currentMode = 'wall';
            updateUI();
        });
        document.getElementById('modeItem').addEventListener('click', () => {
            currentMode = 'item';
            updateUI();
        });
        document.getElementById('modeMove').addEventListener('click', () => {
            currentMode = 'move';
            updateUI();
        });
        document.getElementById('modeRotate').addEventListener('click', () => {
            currentMode = 'rotate';
            updateUI();
        });
        document.getElementById('undo').addEventListener('click', () => {
            if (placedObjects.length) {
                scene.remove(placedObjects.pop());
                updateUI();
            }
        });
        document.getElementById('clear').addEventListener('click', () => {
            placedObjects.forEach(obj => scene.remove(obj));
            placedObjects = [];
            selectedObject = null;
            updateUI();
        });
        document.getElementById('copyBtn').addEventListener('click', () => {
            if (selectedObject) {
                const clone = selectedObject.clone();
                clone.position.x += 1;
                scene.add(clone);
                placedObjects.push(clone);
                selectedObject = clone;
                updateUI();
            }
        });

        // --- Ползунки ---
        document.getElementById('wallLength').addEventListener('input', (e) => wallLength = parseFloat(e.target.value));
        document.getElementById('wallHeight').addEventListener('input', (e) => wallHeight = parseFloat(e.target.value));
        document.getElementById('wallThick').addEventListener('input', (e) => wallThick = parseFloat(e.target.value));
        document.getElementById('wallColor').addEventListener('input', (e) => wallColor = e.target.value);
        document.getElementById('itemShape').addEventListener('change', (e) => itemShape = e.target.value);
        document.getElementById('itemColor').addEventListener('input', (e) => itemColor = e.target.value);
        document.getElementById('itemScale').addEventListener('input', (e) => itemScale = parseFloat(e.target.value));
        document.getElementById('itemRotate').addEventListener('input', (e) => itemRotate = parseFloat(e.target.value));
        document.getElementById('snapGrid').addEventListener('change', (e) => snapEnabled = e.target.checked);

        // --- Анимация ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Telegram (опционально) ---
        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.expand();
            window.Telegram.WebApp.ready();
        }

        // --- Инициализация UI ---
        updateUI();
    </script>
</body>
</html>
