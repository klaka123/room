<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‚ú¶ –£–ú–ù–´–ô –î–ò–ó–ê–ô–ù –ò–ù–¢–ï–†–¨–ï–†–ê ‚Äì –ü–†–ï–ú–ò–£–ú</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:opsz,wght@14..32,300;14..32,400;14..32,500;14..32,600;14..32,700&display=swap');

        body {
            overflow: hidden;
            background: #0e1018;
            color: #f0f4fc;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .top-bar {
            pointer-events: all;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(25, 30, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #ffaa66;
            border-radius: 60px;
            padding: 8px 20px;
            color: white;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffaa66;
        }

        .stats {
            display: flex;
            gap: 30px;
        }

        .main-panels {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex: 1;
            pointer-events: none;
        }

        .catalog-panel {
            pointer-events: all;
            width: 280px;
            background: rgba(25, 30, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #ffaa66;
            border-radius: 40px;
            padding: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .catalog-panel h3 {
            color: #ffaa66;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .item-card {
            background: rgba(0,0,0,0.3);
            border: 1px solid #3a4a6a;
            border-radius: 30px;
            padding: 15px 5px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: 0.2s;
        }

        .item-card:hover {
            border-color: #ffaa66;
            background: rgba(50, 70, 100, 0.5);
            transform: translateY(-3px);
        }

        .item-card.selected {
            border-color: #ffaa66;
            background: rgba(255,170,102,0.2);
            box-shadow: 0 0 0 2px #ffaa66 inset;
        }

        .item-icon {
            font-size: 2.5rem;
        }

        .item-name {
            font-size: 0.8rem;
            color: #ddd;
            text-align: center;
        }

        .tools-panel {
            pointer-events: all;
            width: 280px;
            background: rgba(25, 30, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #ffaa66;
            border-radius: 40px;
            padding: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .tools-panel h4 {
            color: #ffaa66;
            margin-bottom: 12px;
            border-bottom: 1px solid #3a4a6a;
            padding-bottom: 5px;
        }

        .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1 0 auto;
            background: #1e2a3a;
            border: 1px solid #3a4a6a;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 30px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .mode-btn:hover {
            border-color: #ffaa66;
            color: white;
        }

        .mode-btn.active {
            background: #ffaa66;
            color: #0a0c1a;
            border-color: #ffaa66;
        }

        .control-row {
            margin: 15px 0;
        }

        .control-row label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-row select, .control-row input {
            width: 100%;
            padding: 8px 12px;
            background: #1e2a3a;
            border: 1px solid #3a4a6a;
            border-radius: 30px;
            color: white;
        }

        .control-row input[type="color"] {
            height: 45px;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            color: #ccc;
        }

        .action-btn {
            width: 100%;
            background: #ffaa66;
            border: none;
            color: #0a0c1a;
            padding: 12px;
            border-radius: 40px;
            font-weight: bold;
            cursor: pointer;
            margin: 8px 0;
            transition: 0.2s;
        }

        .action-btn:hover {
            background: #ffbb77;
        }

        .hint-bar {
            pointer-events: all;
            align-self: center;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            color: white;
            padding: 12px 30px;
            border-radius: 60px;
            border: 1px solid #ffaa66;
            font-size: 0.9rem;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div class="ui-container">
        <div class="top-bar">
            <div class="logo">‚ú¶ –£–ú–ù–´–ô –î–ò–ó–ê–ô–ù</div>
            <div class="stats">
                <span><i class="fas fa-cube"></i> <span id="statItems">0</span></span>
                <span><i class="fas fa-tachometer-alt"></i> <span id="statFps">0</span> FPS</span>
            </div>
        </div>

        <div class="main-panels">
            <div class="catalog-panel">
                <h3><i class="fas fa-couch"></i> –ö–ê–¢–ê–õ–û–ì</h3>
                <div class="items-grid" id="catalogGrid"></div>
            </div>

            <div class="tools-panel">
                <div class="mode-buttons">
                    <button class="mode-btn active" id="modeWall">–°—Ç–µ–Ω–∞</button>
                    <button class="mode-btn" id="modeItem">–ü—Ä–µ–¥–º–µ—Ç</button>
                    <button class="mode-btn" id="modeMove">–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å</button>
                    <button class="mode-btn" id="modeRotate">–ü–æ–≤–µ—Ä–Ω—É—Ç—å</button>
                </div>

                <div id="wallParams">
                    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–µ–Ω—ã</h4>
                    <div class="control-row">
                        <label>–î–ª–∏–Ω–∞</label>
                        <input type="range" id="wallLength" min="0.5" max="10" step="0.5" value="3">
                    </div>
                    <div class="control-row">
                        <label>–í—ã—Å–æ—Ç–∞</label>
                        <input type="range" id="wallHeight" min="0.5" max="5" step="0.5" value="2.5">
                    </div>
                    <div class="control-row">
                        <label>–¢–æ–ª—â–∏–Ω–∞</label>
                        <input type="range" id="wallThick" min="0.1" max="1" step="0.1" value="0.2">
                    </div>
                    <div class="control-row">
                        <label>–¶–≤–µ—Ç</label>
                        <input type="color" id="wallColor" value="#aaccff">
                    </div>
                </div>

                <div id="itemParams" style="display:none;">
                    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥–º–µ—Ç–∞</h4>
                    <div class="control-row">
                        <label>–¶–≤–µ—Ç</label>
                        <input type="color" id="itemColor" value="#c47e5a">
                    </div>
                    <div class="control-row">
                        <label>–ú–∞—Å—à—Ç–∞–±</label>
                        <input type="range" id="itemScale" min="0.5" max="2.5" step="0.1" value="1">
                    </div>
                    <div class="control-row">
                        <label>–ü–æ–≤–æ—Ä–æ—Ç</label>
                        <input type="range" id="itemRotate" min="0" max="360" step="5" value="0">
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="snapGrid" checked>
                        <label>–ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ (0.5–º)</label>
                    </div>
                </div>

                <button class="action-btn" id="saveBtn"><i class="fas fa-save"></i> –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                <button class="action-btn" id="loadBtn"><i class="fas fa-folder-open"></i> –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                <button class="action-btn" id="copyBtn"><i class="fas fa-copy"></i> –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å (Ctrl+D)</button>
                <button class="action-btn" id="deleteBtn"><i class="fas fa-trash"></i> –£–¥–∞–ª–∏—Ç—å (Del)</button>
                <button class="action-btn" id="clearBtn"><i class="fas fa-broom"></i> –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
                <p style="font-size:0.8rem; color:#aaa; text-align:center;">Shift+–¥–≤–∏–≥–∞—Ç—å ‚Äì –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑</p>
            </div>
        </div>

        <div class="hint-bar" id="hint">–†–µ–∂–∏–º: –°—Ç–µ–Ω–∞ ‚Äì –∫–ª–∏–∫ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏</div>
    </div>

    <canvas id="canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- –°—Ü–µ–Ω–∞ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0e1018);
        scene.fog = new THREE.FogExp2(0x0e1018, 0.002);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 12, 25);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.target.set(0, 2, 0);

        // --- –û—Å–≤–µ—â–µ–Ω–∏–µ ---
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(5, 20, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 50;
        sunLight.shadow.camera.left = -15;
        sunLight.shadow.camera.right = 15;
        sunLight.shadow.camera.top = 15;
        sunLight.shadow.camera.bottom = -15;
        scene.add(sunLight);

        const ambient = new THREE.AmbientLight(0x40486c, 0.6);
        scene.add(ambient);

        const fillLight1 = new THREE.PointLight(0xffaa88, 0.5);
        fillLight1.position.set(-5, 5, 8);
        scene.add(fillLight1);
        const fillLight2 = new THREE.PointLight(0x88aaff, 0.4);
        fillLight2.position.set(6, 4, -6);
        scene.add(fillLight2);

        // --- –ü–æ–ª –∏ —Å–µ—Ç–∫–∞ ---
        const groundGeo = new THREE.CircleGeometry(100, 64);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a2430, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        const gridHelper = new THREE.GridHelper(80, 40, 0xffaa66, 0x3a4a6a);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ---
        let placedObjects = [];          // –≤—Å–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
        let selectedObject = null;        // –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç
        let currentMode = 'wall';         // wall, item, move, rotate
        let snapEnabled = true;           // –ø—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–µ–Ω—ã
        let wallLength = 3, wallHeight = 2.5, wallThick = 0.2;
        let wallColor = '#aaccff';

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥–º–µ—Ç–∞
        let itemColor = '#c47e5a', itemScale = 1, itemRotate = 0;
        let selectedItemType = 'chester'; // —Ç–∏–ø –≤—ã–±—Ä–∞–Ω–Ω–æ–π –º–µ–±–µ–ª–∏ –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞

        // –î–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è/–≤—Ä–∞—â–µ–Ω–∏—è
        let isDragging = false;
        let dragStart = new THREE.Vector2();
        let initialObjectPos = new THREE.Vector3();
        let initialObjectRot = 0;

        // --- –ö–∞—Ç–∞–ª–æ–≥ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ (—Ç–∏–ø—ã) ---
        const catalog = [
            { id: 'chester', name: '–ö—Ä–µ—Å–ª–æ –ß–µ—Å—Ç–µ—Ä', icon: 'ü™ë' },
            { id: 'sofa', name: '–î–∏–≤–∞–Ω', icon: 'üõãÔ∏è' },
            { id: 'table', name: '–°—Ç–æ–ª', icon: 'ü™ë' },
            { id: 'lamp', name: '–¢–æ—Ä—à–µ—Ä', icon: 'üí°' },
            { id: 'plant', name: '–§–∏–∫—É—Å', icon: 'üåø' },
            { id: 'cabinet', name: '–®–∫–∞—Ñ', icon: 'üö™' }
        ];

        // --- –§—É–Ω–∫—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–µ–π (–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ) ---

        function createChesterChair(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const fabricMat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 0.7 });

            // –ù–æ–∂–∫–∏ —Å –∫–æ–ª—ë—Å–∏–∫–∞–º–∏
            const legGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.5, 8);
            const wheelGeo = new THREE.TorusGeometry(0.08, 0.02, 8, 16);
            for (let x = -0.6; x <= 0.6; x+=1.2) {
                for (let z = -0.6; z <= 0.6; z+=1.2) {
                    const leg = new THREE.Mesh(legGeo, woodMat);
                    leg.position.set(x, 0.25, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                    const wheel = new THREE.Mesh(wheelGeo, metalMat);
                    wheel.position.set(x, 0.1, z);
                    wheel.rotation.x = Math.PI/2;
                    wheel.castShadow = true;
                    group.add(wheel);
                }
            }
            // –°–∏–¥–µ–Ω—å–µ —Å –ø–æ–¥—É—à–∫–æ–π
            const seatBase = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.5), woodMat);
            seatBase.position.y = 0.5;
            seatBase.castShadow = true; seatBase.receiveShadow = true;
            group.add(seatBase);
            const cushion = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.2, 1.4), fabricMat);
            cushion.position.y = 0.7;
            cushion.castShadow = true; cushion.receiveShadow = true;
            group.add(cushion);
            // –°–ø–∏–Ω–∫–∞ —Å –ø—É–≥–æ–≤–∏—Ü–∞–º–∏
            const backFrame = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 0.3), woodMat);
            backFrame.position.set(0, 1.5, -0.7);
            backFrame.castShadow = true; backFrame.receiveShadow = true;
            group.add(backFrame);
            const backCushion = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.4, 0.2), fabricMat);
            backCushion.position.set(0, 1.5, -0.6);
            backCushion.castShadow = true; backCushion.receiveShadow = true;
            group.add(backCushion);
            for (let i = -0.6; i <= 0.6; i+=0.6) {
                for (let j = 1.0; j <= 1.8; j+=0.4) {
                    const btn = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8), metalMat);
                    btn.position.set(i, j, -0.55);
                    btn.castShadow = true;
                    group.add(btn);
                }
            }
            // –ü–æ–¥–ª–æ–∫–æ—Ç–Ω–∏–∫–∏
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 1.5), woodMat);
            arm.position.set(-0.95, 1.0, 0);
            arm.castShadow = true; arm.receiveShadow = true;
            group.add(arm);
            const arm2 = arm.clone(); arm2.position.set(0.95, 1.0, 0); group.add(arm2);
            return group;
        }

        function createSofa(color) {
            const group = new THREE.Group();
            const fabricMat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 0.7 });

            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ
            const base = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.2, 1.0), woodMat);
            base.position.y = 0.1; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            // –ù–æ–∂–∫–∏
            const legGeo = new THREE.CylinderGeometry(0.12, 0.15, 0.2, 8);
            [-1.1, 1.1].forEach(x => {
                [-0.4, 0.4].forEach(z => {
                    const leg = new THREE.Mesh(legGeo, woodMat);
                    leg.position.set(x, 0.15, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                });
            });
            // –°–∏–¥–µ–Ω—å—è (—Ç—Ä–∏ –ø–æ–¥—É—à–∫–∏)
            for (let i = -0.8; i <= 0.8; i+=0.8) {
                const cushion = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.3, 0.9), fabricMat);
                cushion.position.set(i, 0.4, 0);
                cushion.castShadow = true; cushion.receiveShadow = true;
                group.add(cushion);
            }
            // –°–ø–∏–Ω–∫–∞
            const back = new THREE.Mesh(new THREE.BoxGeometry(2.4, 1.0, 0.3), fabricMat);
            back.position.set(0, 0.9, -0.4);
            back.castShadow = true; back.receiveShadow = true;
            group.add(back);
            // –ü–æ–¥–ª–æ–∫–æ—Ç–Ω–∏–∫–∏
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 1.0), fabricMat);
            arm.position.set(-1.2, 0.6, 0);
            arm.castShadow = true; arm.receiveShadow = true;
            group.add(arm);
            const arm2 = arm.clone(); arm2.position.set(1.2, 0.6, 0); group.add(arm2);
            return group;
        }

        function createTable(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });

            const top = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.1, 1.2), woodMat);
            top.position.y = 0.9;
            top.castShadow = true; top.receiveShadow = true;
            group.add(top);
            const legGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.8, 8);
            for (let x = -0.8; x <= 0.8; x+=1.6) {
                for (let z = -0.5; z <= 0.5; z+=1.0) {
                    const leg = new THREE.Mesh(legGeo, metalMat);
                    leg.position.set(x, 0.4, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                }
            }
            return group;
        }

        function createLamp(color) {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.3, metalness: 0.8 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.2, 8), metalMat);
            base.position.y = 0.1; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 2.5, 8), metalMat);
            pole.position.y = 1.35; pole.castShadow = true; pole.receiveShadow = true;
            group.add(pole);
            const shade = new THREE.Mesh(new THREE.ConeGeometry(0.6, 0.7, 8), new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.2 }));
            shade.position.y = 2.5; shade.castShadow = true; shade.receiveShadow = true;
            group.add(shade);
            const light = new THREE.PointLight(0xffeedd, 1, 5);
            light.position.y = 2.2; group.add(light);
            return group;
        }

        function createPlant(color) {
            const group = new THREE.Group();
            const potMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const leafMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.5, 8), potMat);
            pot.position.y = 0.25; pot.castShadow = true; pot.receiveShadow = true;
            group.add(pot);
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 1.5, 6), potMat);
            stem.position.y = 1.0; stem.castShadow = true; stem.receiveShadow = true;
            group.add(stem);
            for (let i=0; i<6; i++) {
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.6, 5), leafMat);
                leaf.position.set(Math.cos(i*1.05)*0.6, 1.6, Math.sin(i*1.05)*0.6);
                leaf.rotation.x = 0.2; leaf.rotation.y = i; leaf.castShadow = true;
                group.add(leaf);
            }
            group.userData = { speed: 0.5 + Math.random()*0.5 };
            return group;
        }

        function createCabinet(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0xd4b088, roughness: 0.4 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.0, 0.8), woodMat);
            body.position.y = 1.0; body.castShadow = true; body.receiveShadow = true;
            group.add(body);
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.1), doorMat);
            door.position.set(0, 1.0, 0.41); door.castShadow = true; door.receiveShadow = true;
            group.add(door);
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.2, 6), metalMat);
            handle.position.set(0.4, 1.0, 0.46); handle.rotation.z = Math.PI/2; handle.castShadow = true;
            group.add(handle);
            return group;
        }

        // –§–∞–±—Ä–∏–∫–∞ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
        function createItem(type, color, scale = 1) {
            const colorHex = parseInt(color.slice(1), 16);
            let obj;
            switch(type) {
                case 'chester': obj = createChesterChair(colorHex); break;
                case 'sofa': obj = createSofa(colorHex); break;
                case 'table': obj = createTable(colorHex); break;
                case 'lamp': obj = createLamp(colorHex); break;
                case 'plant': obj = createPlant(colorHex); break;
                case 'cabinet': obj = createCabinet(colorHex); break;
                default: obj = createChesterChair(colorHex);
            }
            obj.scale.set(scale, scale, scale);
            return obj;
        }

        // --- –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ (—Ä–∞–º–∫–∞) ---
        function highlightObject(obj, state) {
            // –ü—Ä–æ—Å—Ç–µ–π—à–∏–π —Å–ø–æ—Å–æ–± ‚Äì –¥–æ–±–∞–≤–∏—Ç—å/—É–¥–∞–ª–∏—Ç—å BoxHelper
            // –ù–æ –º—ã –±—É–¥–µ–º —Ö—Ä–∞–Ω–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≥–∞–±–∞—Ä–∏—Ç–Ω—ã–π –∫—É–±
            if (state && obj) {
                // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π helper
                scene.children.forEach(child => {
                    if (child.isLineSegments && child.userData.isHelper) scene.remove(child);
                });
                const box = new THREE.BoxHelper(obj, 0xffaa66);
                box.userData.isHelper = true;
                scene.add(box);
            } else {
                scene.children.forEach(child => {
                    if (child.isLineSegments && child.userData.isHelper) scene.remove(child);
                });
            }
        }

        // --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ ---
        function updateStats() {
            document.getElementById('statItems').innerText = placedObjects.length;
        }

        // --- –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ–¥ –º—ã—à—å—é —Å —É—á—ë—Ç–æ–º –ø—Ä–∏–≤—è–∑–∫–∏ –∏ –ø–æ–∏—Å–∫–∞ –æ–±—ä–µ–∫—Ç–∞ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –Ω–∞ –Ω—ë–º ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();

        function getPlacementPosition(event) {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏
            const intersects = raycaster.intersectObjects(placedObjects, true); // true ‚Äì —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ
            if (intersects.length > 0) {
                // –ù–∞—à–ª–∏ –æ–±—ä–µ–∫—Ç, –≤—ã—á–∏—Å–ª—è–µ–º –µ–≥–æ –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω—å
                const hit = intersects[0].object;
                // –ü–æ–ª—É—á–∞–µ–º bounding box –æ–±—ä–µ–∫—Ç–∞ (–≥—Ä—É–ø–ø—ã)
                const box = new THREE.Box3().setFromObject(hit);
                const topY = box.max.y;
                // –ü–æ–∑–∏—Ü–∏—è –ø–æ–¥ –º—ã—à—å—é –Ω–∞ –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏? –ù–æ –ø—Ä–æ—â–µ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω—å
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è, –Ω–æ y –ø–æ–¥–Ω–∏–º–∞–µ–º –¥–æ topY + –ø–æ–ª–æ–≤–∏–Ω–∞ –≤—ã—Å–æ—Ç—ã –Ω–æ–≤–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞
                // –í—ã—Å–æ—Ç—É –Ω–æ–≤–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞ –ø–æ–∫–∞ –Ω–µ –∑–Ω–∞–µ–º, –Ω–æ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å scale –∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –≤—ã—Å–æ—Ç—É ~1
                // –£–ø—Ä–æ—Å—Ç–∏–º: —Å—Ç–∞–≤–∏–º –Ω–∞ –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω—å –æ–±—ä–µ–∫—Ç–∞-–æ—Å–Ω–æ–≤–∞–Ω–∏—è, –±–µ–∑ —Ç–æ—á–Ω–æ–≥–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –ø–æ XZ
                // –í–æ–∑—å–º—ë–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –∏ –ø–æ–¥–Ω–∏–º–µ–º –µ—ë
                let point = hit.worldToLocal(intersects[0].point.clone()); // –Ω–µ –Ω—É–∂–Ω–æ, –ø—Ä–æ—â–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é
                point = intersects[0].point.clone();
                // –ï—Å–ª–∏ –Ω—É–∂–Ω–∞ –ø—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ, –æ–∫—Ä—É–≥–ª—è–µ–º
                if (snapEnabled) {
                    point.x = Math.round(point.x / 0.5) * 0.5;
                    point.z = Math.round(point.z / 0.5) * 0.5;
                }
                // –ù–æ Y –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å topY + halfHeight –Ω–æ–≤–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞
                return { point, baseObject: hit, topY };
            }

            // –ï—Å–ª–∏ –Ω–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–ª–æ—Å–∫–æ—Å—Ç—å –ø–æ–ª–∞
            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                let point = intersectPoint.clone();
                if (snapEnabled) {
                    point.x = Math.round(point.x / 0.5) * 0.5;
                    point.z = Math.round(point.z / 0.5) * 0.5;
                }
                point.y = 0; // –ø–æ–ª
                return { point, baseObject: null, topY: 0 };
            }
            return null;
        }

        // --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –º—ã—à–∏ ---
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('.ui-container')) return;
            if (e.button !== 0) return;

            if (currentMode === 'move' || currentMode === 'rotate') {
                // –í—ã–¥–µ–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞
                mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(placedObjects, true);
                if (intersects.length > 0) {
                    // –ò—â–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π –æ–±—ä–µ–∫—Ç (—Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫—É—é –≥—Ä—É–ø–ø—É)
                    let obj = intersects[0].object;
                    while (obj.parent && !placedObjects.includes(obj)) {
                        obj = obj.parent;
                    }
                    if (placedObjects.includes(obj)) {
                        selectedObject = obj;
                        highlightObject(selectedObject, true);
                        isDragging = true;
                        dragStart.set(e.clientX, e.clientY);
                        initialObjectPos.copy(selectedObject.position);
                        if (currentMode === 'rotate') {
                            initialObjectRot = selectedObject.rotation.y;
                        }
                    }
                } else {
                    // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                    highlightObject(null, false);
                    selectedObject = null;
                }
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging || !selectedObject) return;

            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;

            if (currentMode === 'move') {
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
                if (e.shiftKey) {
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
                    selectedObject.position.y = initialObjectPos.y + dy * 0.02;
                } else {
                    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ (–ø–æ XZ)
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –º—ã—à–∏ –≤ —Å–º–µ—â–µ–Ω–∏–µ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
                    // –ü—Ä–æ—Å—Ç–µ–π—à–∏–π —Å–ø–æ—Å–æ–±: –¥–≤–∏–≥–∞–µ–º –ø–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –∫–∞–º–µ—Ä—ã
                    const deltaX = dx * 0.01 * (camera.position.y / 5);
                    const deltaZ = dy * 0.01 * (camera.position.y / 5);
                    selectedObject.position.x = initialObjectPos.x + deltaX;
                    selectedObject.position.z = initialObjectPos.z + deltaZ;
                }
            } else if (currentMode === 'rotate') {
                // –í—Ä–∞—â–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ Y
                selectedObject.rotation.y = initialObjectRot + dx * 0.01;
            }
        });

        renderer.domElement.addEventListener('mouseup', (e) => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('.ui-container')) return;
            if (isDragging) return; // —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ–º

            if (currentMode === 'wall') {
                const placement = getPlacementPosition(e);
                if (!placement) return;
                let pos = placement.point;
                // –°—Ç–µ–Ω–∞ –≤—Å–µ–≥–¥–∞ –Ω–∞ –ø–æ–ª—É, –ø–æ—ç—Ç–æ–º—É –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º baseObject
                pos.y = wallHeight / 2;
                const mat = new THREE.MeshStandardMaterial({ color: parseInt(wallColor.slice(1), 16), roughness: 0.7 });
                const geo = new THREE.BoxGeometry(wallThick, wallHeight, wallLength);
                const wall = new THREE.Mesh(geo, mat);
                wall.position.copy(pos);
                wall.castShadow = true; wall.receiveShadow = true;
                scene.add(wall);
                placedObjects.push(wall);
            } else if (currentMode === 'item') {
                const placement = getPlacementPosition(e);
                if (!placement) return;
                const { point, baseObject, topY } = placement;
                const item = createItem(selectedItemType, itemColor, itemScale);
                item.position.copy(point);
                // –ï—Å–ª–∏ –µ—Å—Ç—å –±–∞–∑–æ–≤—ã–π –æ–±—ä–µ–∫—Ç, —Å—Ç–∞–≤–∏–º –Ω–∞ –µ–≥–æ –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω—å
                if (baseObject) {
                    // –í—ã—á–∏—Å–ª—è–µ–º –≤—ã—Å–æ—Ç—É –Ω–æ–≤–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞ (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ)
                    const box = new THREE.Box3().setFromObject(item);
                    const itemHeight = box.max.y - box.min.y;
                    item.position.y = topY + itemHeight / 2;
                } else {
                    item.position.y = itemScale * 0.5; // –Ω–∞ –ø–æ–ª—É
                }
                item.rotation.y = itemRotate * Math.PI / 180;
                scene.add(item);
                placedObjects.push(item);
                // –ê–Ω–∏–º–∞—Ü–∏—è –¥–ª—è —Ä–∞—Å—Ç–µ–Ω–∏–π
                if (selectedItemType === 'plant' || selectedItemType === 'ficus') {
                    item.userData.speed = 0.5 + Math.random() * 0.5;
                }
            }
            updateStats();
        });

        // --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ ---
        document.addEventListener('keydown', (e) => {
            if (e.target.closest('input,select')) return;
            if (e.key === 'Delete' && selectedObject) {
                scene.remove(selectedObject);
                placedObjects = placedObjects.filter(obj => obj !== selectedObject);
                highlightObject(null, false);
                selectedObject = null;
                updateStats();
            }
            if (e.ctrlKey && e.key === 'd' && selectedObject) {
                const clone = selectedObject.clone();
                clone.position.x += 1;
                scene.add(clone);
                placedObjects.push(clone);
                selectedObject = clone;
                highlightObject(selectedObject, true);
                updateStats();
            }
        });

        // --- UI –∫–Ω–æ–ø–∫–∏ ---
        document.getElementById('modeWall').addEventListener('click', () => {
            currentMode = 'wall';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeWall').classList.add('active');
            document.getElementById('wallParams').style.display = 'block';
            document.getElementById('itemParams').style.display = 'none';
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –°—Ç–µ–Ω–∞ ‚Äì –∫–ª–∏–∫ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏';
        });
        document.getElementById('modeItem').addEventListener('click', () => {
            currentMode = 'item';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeItem').classList.add('active');
            document.getElementById('wallParams').style.display = 'none';
            document.getElementById('itemParams').style.display = 'block';
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –ü—Ä–µ–¥–º–µ—Ç ‚Äì –∫–ª–∏–∫ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è (–Ω–∞ –ø–æ–ª –∏–ª–∏ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç)';
        });
        document.getElementById('modeMove').addEventListener('click', () => {
            currentMode = 'move';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeMove').classList.add('active');
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ ‚Äì –∫–ª–∏–∫ –ø–æ –æ–±—ä–µ–∫—Ç—É –∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ (Shift ‚Äì –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑)';
        });
        document.getElementById('modeRotate').addEventListener('click', () => {
            currentMode = 'rotate';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeRotate').classList.add('active');
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –ü–æ–≤–æ—Ä–æ—Ç ‚Äì –∫–ª–∏–∫ –ø–æ –æ–±—ä–µ–∫—Ç—É –∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ';
        });

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–µ–Ω
        document.getElementById('wallLength').addEventListener('input', (e) => wallLength = parseFloat(e.target.value));
        document.getElementById('wallHeight').addEventListener('input', (e) => wallHeight = parseFloat(e.target.value));
        document.getElementById('wallThick').addEventListener('input', (e) => wallThick = parseFloat(e.target.value));
        document.getElementById('wallColor').addEventListener('input', (e) => wallColor = e.target.value);

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥–º–µ—Ç–æ–≤
        document.getElementById('itemColor').addEventListener('input', (e) => itemColor = e.target.value);
        document.getElementById('itemScale').addEventListener('input', (e) => itemScale = parseFloat(e.target.value));
        document.getElementById('itemRotate').addEventListener('input', (e) => itemRotate = parseFloat(e.target.value));
        document.getElementById('snapGrid').addEventListener('change', (e) => snapEnabled = e.target.checked);

        // –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π
        document.getElementById('saveBtn').addEventListener('click', () => {
            const data = placedObjects.map(obj => ({
                type: 'unknown', // –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–∏–ø, —Ç–æ–ª—å–∫–æ –ø–æ–∑–∏—Ü–∏—é –∏ —Ü–≤–µ—Ç
                pos: [obj.position.x, obj.position.y, obj.position.z],
                rot: [obj.rotation.x, obj.rotation.y, obj.rotation.z],
                scale: [obj.scale.x, obj.scale.y, obj.scale.z],
                color: obj.material?.color?.getHex()
            }));
            localStorage.setItem('design_scene', JSON.stringify(data));
            alert('–°—Ü–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞');
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            const data = JSON.parse(localStorage.getItem('design_scene'));
            if (!data) return;
            placedObjects.forEach(obj => scene.remove(obj));
            placedObjects = [];
            data.forEach(d => {
                const mat = new THREE.MeshStandardMaterial({ color: d.color || 0xffffff });
                const geo = new THREE.BoxGeometry(1,1,1);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(d.pos[0], d.pos[1], d.pos[2]);
                mesh.rotation.set(d.rot[0], d.rot[1], d.rot[2]);
                mesh.scale.set(d.scale[0], d.scale[1], d.scale[2]);
                mesh.castShadow = true; mesh.receiveShadow = true;
                scene.add(mesh);
                placedObjects.push(mesh);
            });
            updateStats();
        });

        document.getElementById('copyBtn').addEventListener('click', () => {
            if (selectedObject) {
                const clone = selectedObject.clone();
                clone.position.x += 1;
                scene.add(clone);
                placedObjects.push(clone);
                selectedObject = clone;
                highlightObject(selectedObject, true);
                updateStats();
            }
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedObject) {
                scene.remove(selectedObject);
                placedObjects = placedObjects.filter(obj => obj !== selectedObject);
                highlightObject(null, false);
                selectedObject = null;
                updateStats();
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            placedObjects.forEach(obj => scene.remove(obj));
            placedObjects = [];
            highlightObject(null, false);
            selectedObject = null;
            updateStats();
        });

        // --- –ö–∞—Ç–∞–ª–æ–≥ ---
        function loadCatalog() {
            const grid = document.getElementById('catalogGrid');
            catalog.forEach(item => {
                const card = document.createElement('div');
                card.className = 'item-card';
                card.dataset.id = item.id;
                card.innerHTML = `<div class="item-icon">${item.icon}</div><div class="item-name">${item.name}</div>`;
                card.addEventListener('click', () => {
                    document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedItemType = item.id;
                });
                grid.appendChild(card);
            });
            // –ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤—ã–±—Ä–∞–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            document.querySelector('.item-card')?.classList.add('selected');
        }

        // --- –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞—Å—Ç–µ–Ω–∏–π ---
        function animatePlants() {
            placedObjects.forEach(obj => {
                if (obj.userData && obj.userData.speed) {
                    obj.rotation.z = Math.sin(Date.now() * 0.001 * obj.userData.speed) * 0.02;
                }
            });
        }

        // --- FPS ---
        let lastTime = performance.now();
        let frames = 0;
        function updateFPS() {
            frames++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('statFps').innerText = frames;
                frames = 0;
                lastTime = now;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            animatePlants();
            controls.update();
            renderer.render(scene, camera);
            updateFPS();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.expand();
            window.Telegram.WebApp.ready();
        }

        loadCatalog();
        updateStats();
        animate();
    </script>
</body>
</html>
