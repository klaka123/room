<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‚ú¶ –£–ú–ù–´–ô –î–ò–ó–ê–ô–ù ‚Äì –ú–ï–ë–ï–õ–¨+ –í–´–î–ï–õ–ï–ù–ò–ï</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:opsz,wght@14..32,300;14..32,400;14..32,500;14..32,600;14..32,700&display=swap');

        body {
            overflow: hidden;
            background: #0e1018;
            color: #f0f4fc;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .top-bar {
            pointer-events: all;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(25, 30, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #ffaa66;
            border-radius: 60px;
            padding: 8px 20px;
            color: white;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffaa66;
        }

        .stats {
            display: flex;
            gap: 30px;
        }

        .main-panels {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex: 1;
            pointer-events: none;
        }

        .catalog-panel {
            pointer-events: all;
            width: 300px;
            background: rgba(25, 30, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #ffaa66;
            border-radius: 40px;
            padding: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .catalog-panel h3 {
            color: #ffaa66;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .item-card {
            background: rgba(0,0,0,0.3);
            border: 1px solid #3a4a6a;
            border-radius: 30px;
            padding: 15px 5px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: 0.2s;
        }

        .item-card:hover {
            border-color: #ffaa66;
            background: rgba(50, 70, 100, 0.5);
            transform: translateY(-3px);
        }

        .item-card.selected {
            border-color: #ffaa66;
            background: rgba(255,170,102,0.2);
            box-shadow: 0 0 0 2px #ffaa66 inset;
        }

        .item-icon {
            font-size: 2.5rem;
        }

        .item-name {
            font-size: 0.8rem;
            color: #ddd;
            text-align: center;
        }

        .tools-panel {
            pointer-events: all;
            width: 300px;
            background: rgba(25, 30, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #ffaa66;
            border-radius: 40px;
            padding: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .tools-panel h4 {
            color: #ffaa66;
            margin-bottom: 12px;
            border-bottom: 1px solid #3a4a6a;
            padding-bottom: 5px;
        }

        .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1 0 auto;
            background: #1e2a3a;
            border: 1px solid #3a4a6a;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 30px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .mode-btn:hover {
            border-color: #ffaa66;
            color: white;
        }

        .mode-btn.active {
            background: #ffaa66;
            color: #0a0c1a;
            border-color: #ffaa66;
        }

        .control-row {
            margin: 15px 0;
        }

        .control-row label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-row select, .control-row input {
            width: 100%;
            padding: 8px 12px;
            background: #1e2a3a;
            border: 1px solid #3a4a6a;
            border-radius: 30px;
            color: white;
        }

        .control-row input[type="color"] {
            height: 45px;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            color: #ccc;
        }

        .action-btn {
            width: 100%;
            background: #ffaa66;
            border: none;
            color: #0a0c1a;
            padding: 12px;
            border-radius: 40px;
            font-weight: bold;
            cursor: pointer;
            margin: 8px 0;
            transition: 0.2s;
        }

        .action-btn:hover {
            background: #ffbb77;
        }

        .hint-bar {
            pointer-events: all;
            align-self: center;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            color: white;
            padding: 12px 30px;
            border-radius: 60px;
            border: 1px solid #ffaa66;
            font-size: 0.9rem;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div class="ui-container">
        <div class="top-bar">
            <div class="logo">‚ú¶ –£–ú–ù–´–ô –î–ò–ó–ê–ô–ù</div>
            <div class="stats">
                <span><i class="fas fa-cube"></i> <span id="statItems">0</span></span>
                <span><i class="fas fa-tachometer-alt"></i> <span id="statFps">0</span> FPS</span>
            </div>
        </div>

        <div class="main-panels">
            <div class="catalog-panel">
                <h3><i class="fas fa-couch"></i> –ö–ê–¢–ê–õ–û–ì</h3>
                <div class="items-grid" id="catalogGrid"></div>
            </div>

            <div class="tools-panel">
                <div class="mode-buttons">
                    <button class="mode-btn active" id="modeWall">–°—Ç–µ–Ω–∞</button>
                    <button class="mode-btn" id="modeItem">–ü—Ä–µ–¥–º–µ—Ç</button>
                    <button class="mode-btn" id="modeMove">–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å</button>
                    <button class="mode-btn" id="modeRotate">–ü–æ–≤–µ—Ä–Ω—É—Ç—å</button>
                </div>

                <div id="wallParams">
                    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–µ–Ω—ã</h4>
                    <div class="control-row">
                        <label>–î–ª–∏–Ω–∞</label>
                        <input type="range" id="wallLength" min="0.5" max="10" step="0.5" value="3">
                    </div>
                    <div class="control-row">
                        <label>–í—ã—Å–æ—Ç–∞</label>
                        <input type="range" id="wallHeight" min="0.5" max="5" step="0.5" value="2.5">
                    </div>
                    <div class="control-row">
                        <label>–¢–æ–ª—â–∏–Ω–∞</label>
                        <input type="range" id="wallThick" min="0.1" max="1" step="0.1" value="0.2">
                    </div>
                    <div class="control-row">
                        <label>–¶–≤–µ—Ç</label>
                        <input type="color" id="wallColor" value="#aaccff">
                    </div>
                </div>

                <div id="itemParams" style="display:none;">
                    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥–º–µ—Ç–∞</h4>
                    <div class="control-row">
                        <label>–¶–≤–µ—Ç</label>
                        <input type="color" id="itemColor" value="#c47e5a">
                    </div>
                    <div class="control-row">
                        <label>–ú–∞—Å—à—Ç–∞–±</label>
                        <input type="range" id="itemScale" min="0.5" max="2.5" step="0.1" value="1">
                    </div>
                    <div class="control-row">
                        <label>–ü–æ–≤–æ—Ä–æ—Ç</label>
                        <input type="range" id="itemRotate" min="0" max="360" step="5" value="0">
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="snapGrid" checked>
                        <label>–ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ (0.5–º)</label>
                    </div>
                </div>

                <button class="action-btn" id="saveBtn"><i class="fas fa-save"></i> –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                <button class="action-btn" id="loadBtn"><i class="fas fa-folder-open"></i> –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                <button class="action-btn" id="copyBtn"><i class="fas fa-copy"></i> –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å (Ctrl+D)</button>
                <button class="action-btn" id="deleteBtn"><i class="fas fa-trash"></i> –£–¥–∞–ª–∏—Ç—å (Del)</button>
                <button class="action-btn" id="clearBtn"><i class="fas fa-broom"></i> –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
                <p style="font-size:0.8rem; color:#aaa; text-align:center;">Alt+–∫–ª–∏–∫ ‚Äì –≤—ã–¥–µ–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç</p>
            </div>
        </div>

        <div class="hint-bar" id="hint">–†–µ–∂–∏–º: –°—Ç–µ–Ω–∞ ‚Äì –∫–ª–∏–∫ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ | Alt+–∫–ª–∏–∫ –≤—ã–¥–µ–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç</div>
    </div>

    <canvas id="canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- –°—Ü–µ–Ω–∞ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0e1018);
        scene.fog = new THREE.FogExp2(0x0e1018, 0.002);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 12, 25);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.target.set(0, 2, 0);

        // --- –û—Å–≤–µ—â–µ–Ω–∏–µ ---
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(5, 20, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 50;
        sunLight.shadow.camera.left = -15;
        sunLight.shadow.camera.right = 15;
        sunLight.shadow.camera.top = 15;
        sunLight.shadow.camera.bottom = -15;
        scene.add(sunLight);

        const ambient = new THREE.AmbientLight(0x40486c, 0.6);
        scene.add(ambient);

        const fillLight1 = new THREE.PointLight(0xffaa88, 0.5);
        fillLight1.position.set(-5, 5, 8);
        scene.add(fillLight1);
        const fillLight2 = new THREE.PointLight(0x88aaff, 0.4);
        fillLight2.position.set(6, 4, -6);
        scene.add(fillLight2);

        // --- –ü–æ–ª (—Ç–µ–ø–µ—Ä—å –±–µ–ª—ã–π) ---
        const groundGeo = new THREE.CircleGeometry(100, 64);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 }); // –±–µ–ª—ã–π –ø–æ–ª
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- –°–µ—Ç–∫–∞ (—Ç—ë–º–Ω–æ-—Å–µ—Ä–∞—è) ---
        const gridHelper = new THREE.GridHelper(80, 40, 0x333333, 0x333333);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ---
        let placedObjects = [];          // –≤—Å–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
        let selectedObject = null;        // –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç
        let currentMode = 'wall';         // wall, item, move, rotate
        let snapEnabled = true;           // –ø—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–µ–Ω—ã
        let wallLength = 3, wallHeight = 2.5, wallThick = 0.2;
        let wallColor = '#aaccff';

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥–º–µ—Ç–∞
        let itemColor = '#c47e5a', itemScale = 1, itemRotate = 0;
        let selectedItemType = 'chester'; // —Ç–∏–ø –≤—ã–±—Ä–∞–Ω–Ω–æ–π –º–µ–±–µ–ª–∏ –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞

        // –î–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è/–≤—Ä–∞—â–µ–Ω–∏—è
        let isDragging = false;
        let dragStart = new THREE.Vector2();
        let initialObjectPos = new THREE.Vector3();
        let initialObjectRot = 0;

        // --- –ö–∞—Ç–∞–ª–æ–≥ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ (—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π) ---
        const catalog = [
            { id: 'chester', name: '–ö—Ä–µ—Å–ª–æ –ß–µ—Å—Ç–µ—Ä', icon: 'ü™ë' },
            { id: 'eames', name: '–°—Ç—É–ª Eames', icon: 'üí∫' },
            { id: 'sofa', name: '–î–∏–≤–∞–Ω', icon: 'üõãÔ∏è' },
            { id: 'corner_sofa', name: '–î–∏–≤–∞–Ω —É–≥–ª–æ–≤–æ–π', icon: 'üõãÔ∏è' },
            { id: 'table', name: '–°—Ç–æ–ª', icon: 'ü™ë' },
            { id: 'coffee_table', name: '–ñ—É—Ä–Ω–∞–ª—å–Ω—ã–π —Å—Ç–æ–ª–∏–∫', icon: 'ü™ë' },
            { id: 'lamp', name: '–¢–æ—Ä—à–µ—Ä', icon: 'üí°' },
            { id: 'floor_lamp', name: '–¢–æ—Ä—à–µ—Ä Arc', icon: 'üí°' },
            { id: 'plant', name: '–§–∏–∫—É—Å', icon: 'üåø' },
            { id: 'palm', name: '–ü–∞–ª—å–º–∞', icon: 'üå¥' },
            { id: 'cabinet', name: '–®–∫–∞—Ñ', icon: 'üö™' },
            { id: 'wardrobe', name: '–®–∫–∞—Ñ-–∫—É–ø–µ', icon: 'üö™' },
            { id: 'dresser', name: '–ö–æ–º–æ–¥', icon: 'üóÑÔ∏è' },
            { id: 'bed', name: '–ö—Ä–æ–≤–∞—Ç—å', icon: 'üõèÔ∏è' },
            { id: 'mirror', name: '–ó–µ—Ä–∫–∞–ª–æ', icon: 'ü™û' },
            { id: 'clock', name: '–ß–∞—Å—ã', icon: '‚è∞' }
        ];

        // --- –§—É–Ω–∫—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–µ–π (–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ) ---

        function createChesterChair(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const fabricMat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 0.7 });

            // –ù–æ–∂–∫–∏ —Å –∫–æ–ª—ë—Å–∏–∫–∞–º–∏
            const legGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.5, 8);
            const wheelGeo = new THREE.TorusGeometry(0.08, 0.02, 8, 16);
            for (let x = -0.6; x <= 0.6; x+=1.2) {
                for (let z = -0.6; z <= 0.6; z+=1.2) {
                    const leg = new THREE.Mesh(legGeo, woodMat);
                    leg.position.set(x, 0.25, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                    const wheel = new THREE.Mesh(wheelGeo, metalMat);
                    wheel.position.set(x, 0.1, z);
                    wheel.rotation.x = Math.PI/2;
                    wheel.castShadow = true;
                    group.add(wheel);
                }
            }
            // –°–∏–¥–µ–Ω—å–µ —Å –ø–æ–¥—É—à–∫–æ–π
            const seatBase = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.5), woodMat);
            seatBase.position.y = 0.5;
            seatBase.castShadow = true; seatBase.receiveShadow = true;
            group.add(seatBase);
            const cushion = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.2, 1.4), fabricMat);
            cushion.position.y = 0.7;
            cushion.castShadow = true; cushion.receiveShadow = true;
            group.add(cushion);
            // –°–ø–∏–Ω–∫–∞ —Å –ø—É–≥–æ–≤–∏—Ü–∞–º–∏
            const backFrame = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 0.3), woodMat);
            backFrame.position.set(0, 1.5, -0.7);
            backFrame.castShadow = true; backFrame.receiveShadow = true;
            group.add(backFrame);
            const backCushion = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.4, 0.2), fabricMat);
            backCushion.position.set(0, 1.5, -0.6);
            backCushion.castShadow = true; backCushion.receiveShadow = true;
            group.add(backCushion);
            for (let i = -0.6; i <= 0.6; i+=0.6) {
                for (let j = 1.0; j <= 1.8; j+=0.4) {
                    const btn = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8), metalMat);
                    btn.position.set(i, j, -0.55);
                    btn.castShadow = true;
                    group.add(btn);
                }
            }
            // –ü–æ–¥–ª–æ–∫–æ—Ç–Ω–∏–∫–∏
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 1.5), woodMat);
            arm.position.set(-0.95, 1.0, 0);
            arm.castShadow = true; arm.receiveShadow = true;
            group.add(arm);
            const arm2 = arm.clone(); arm2.position.set(0.95, 1.0, 0); group.add(arm2);
            return group;
        }

        function createEamesChair(color) {
            const group = new THREE.Group();
            const plasticMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x5a3a2a, roughness: 0.6 });

            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.1, 12), woodMat);
            base.position.y = 0.05; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            // –°–∏–¥–µ–Ω—å–µ
            const seat = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16), plasticMat);
            seat.scale.set(1.2, 0.3, 1.1);
            seat.position.y = 0.4; seat.castShadow = true; seat.receiveShadow = true;
            group.add(seat);
            // –°–ø–∏–Ω–∫–∞
            const back = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16), plasticMat);
            back.scale.set(1.2, 0.7, 0.3);
            back.position.set(0, 0.9, -0.4); back.castShadow = true; back.receiveShadow = true;
            group.add(back);
            // –ü–æ–¥–ª–æ–∫–æ—Ç–Ω–∏–∫–∏
            const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
            const armL = new THREE.Mesh(armGeo, woodMat);
            armL.position.set(-0.7, 0.6, 0); armL.rotation.z = 0.2; armL.castShadow = true;
            group.add(armL);
            const armR = armL.clone(); armR.position.set(0.7, 0.6, 0); armR.rotation.z = -0.2; group.add(armR);
            return group;
        }

        function createSofa(color) {
            const group = new THREE.Group();
            const fabricMat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });

            const base = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.2, 1.0), woodMat);
            base.position.y = 0.1; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            const legGeo = new THREE.CylinderGeometry(0.12, 0.15, 0.2, 8);
            [-1.1, 1.1].forEach(x => {
                [-0.4, 0.4].forEach(z => {
                    const leg = new THREE.Mesh(legGeo, woodMat);
                    leg.position.set(x, 0.15, z); leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                });
            });
            for (let i = -0.8; i <= 0.8; i+=0.8) {
                const cushion = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.3, 0.9), fabricMat);
                cushion.position.set(i, 0.4, 0); cushion.castShadow = true; cushion.receiveShadow = true;
                group.add(cushion);
            }
            const back = new THREE.Mesh(new THREE.BoxGeometry(2.4, 1.0, 0.3), fabricMat);
            back.position.set(0, 0.9, -0.4); back.castShadow = true; back.receiveShadow = true;
            group.add(back);
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 1.0), fabricMat);
            arm.position.set(-1.2, 0.6, 0); arm.castShadow = true; arm.receiveShadow = true;
            group.add(arm);
            const arm2 = arm.clone(); arm2.position.set(1.2, 0.6, 0); group.add(arm2);
            return group;
        }

        function createCornerSofa(color) {
            const group = new THREE.Group();
            const fabricMat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });

            const base = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.2, 2.0), woodMat);
            base.position.set(0.5, 0.1, 0.5); base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            const legGeo = new THREE.CylinderGeometry(0.12, 0.15, 0.2, 8);
            [0, 1.0].forEach(x => {
                [0, 1.0].forEach(z => {
                    const leg = new THREE.Mesh(legGeo, woodMat);
                    leg.position.set(x, 0.15, z); leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                });
            });
            const cushion1 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.3, 0.9), fabricMat);
            cushion1.position.set(0, 0.4, 0); cushion1.castShadow = true; cushion1.receiveShadow = true;
            group.add(cushion1);
            const cushion2 = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.3, 0.9), fabricMat);
            cushion2.position.set(1.0, 0.4, 1.0); cushion2.castShadow = true; cushion2.receiveShadow = true;
            group.add(cushion2);
            const back1 = new THREE.Mesh(new THREE.BoxGeometry(2.0, 1.0, 0.3), fabricMat);
            back1.position.set(0.5, 0.9, -0.5); back1.castShadow = true; back1.receiveShadow = true;
            group.add(back1);
            const back2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 2.0), fabricMat);
            back2.position.set(-0.5, 0.9, 0.5); back2.castShadow = true; back2.receiveShadow = true;
            group.add(back2);
            return group;
        }

        function createTable(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });

            const top = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.1, 1.2), woodMat);
            top.position.y = 0.9; top.castShadow = true; top.receiveShadow = true;
            group.add(top);
            const legGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.8, 8);
            for (let x = -0.8; x <= 0.8; x+=1.6) {
                for (let z = -0.5; z <= 0.5; z+=1.0) {
                    const leg = new THREE.Mesh(legGeo, metalMat);
                    leg.position.set(x, 0.4, z); leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                }
            }
            return group;
        }

        function createCoffeeTable(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.0, transparent: true, opacity: 0.7 });

            const top = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.05, 0.8), glassMat);
            top.position.y = 0.45; top.castShadow = true; top.receiveShadow = true;
            group.add(top);
            const legGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.4, 8);
            for (let x = -0.5; x <= 0.5; x+=1.0) {
                for (let z = -0.3; z <= 0.3; z+=0.6) {
                    const leg = new THREE.Mesh(legGeo, woodMat);
                    leg.position.set(x, 0.2, z); leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                }
            }
            return group;
        }

        function createLamp(color) {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.3, metalness: 0.8 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.2, 8), metalMat);
            base.position.y = 0.1; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 2.5, 8), metalMat);
            pole.position.y = 1.35; pole.castShadow = true; pole.receiveShadow = true;
            group.add(pole);
            const shade = new THREE.Mesh(new THREE.ConeGeometry(0.6, 0.7, 8), new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.2 }));
            shade.position.y = 2.5; shade.castShadow = true; shade.receiveShadow = true;
            group.add(shade);
            const light = new THREE.PointLight(0xffeedd, 1, 5);
            light.position.y = 2.2; group.add(light);
            return group;
        }

        function createFloorLamp(color) {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.8 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 0.1, 8), metalMat);
            base.position.y = 0.05; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.06, 2.0, 8), metalMat);
            pole.position.y = 1.05; pole.castShadow = true; pole.receiveShadow = true;
            group.add(pole);
            const shade = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.5, 8), new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.2 }));
            shade.position.y = 2.0; shade.castShadow = true; shade.receiveShadow = true;
            group.add(shade);
            const light = new THREE.PointLight(0xffeedd, 0.8, 5);
            light.position.y = 1.9; group.add(light);
            return group;
        }

        function createPlant(color) {
            const group = new THREE.Group();
            const potMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const leafMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.5, 8), potMat);
            pot.position.y = 0.25; pot.castShadow = true; pot.receiveShadow = true;
            group.add(pot);
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 1.5, 6), potMat);
            stem.position.y = 1.0; stem.castShadow = true; stem.receiveShadow = true;
            group.add(stem);
            for (let i=0; i<6; i++) {
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.6, 5), leafMat);
                leaf.position.set(Math.cos(i*1.05)*0.6, 1.6, Math.sin(i*1.05)*0.6);
                leaf.rotation.x = 0.2; leaf.rotation.y = i; leaf.castShadow = true;
                group.add(leaf);
            }
            group.userData = { speed: 0.5 + Math.random()*0.5 };
            return group;
        }

        function createPalm(color) {
            const group = new THREE.Group();
            const potMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const leafMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.5, 8), potMat);
            pot.position.y = 0.25; pot.castShadow = true; pot.receiveShadow = true;
            group.add(pot);
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 2.0, 6), potMat);
            trunk.position.y = 1.2; trunk.castShadow = true; trunk.receiveShadow = true;
            group.add(trunk);
            for (let i=0; i<8; i++) {
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.8, 5), leafMat);
                leaf.position.set(Math.cos(i)*0.8, 2.0, Math.sin(i)*0.8);
                leaf.rotation.z = 0.3; leaf.rotation.y = i; leaf.castShadow = true;
                group.add(leaf);
            }
            group.userData = { speed: 0.3 };
            return group;
        }

        function createCabinet(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0xd4b088, roughness: 0.4 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.0, 0.8), woodMat);
            body.position.y = 1.0; body.castShadow = true; body.receiveShadow = true;
            group.add(body);
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.1), doorMat);
            door.position.set(0, 1.0, 0.41); door.castShadow = true; door.receiveShadow = true;
            group.add(door);
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.2, 6), metalMat);
            handle.position.set(0.4, 1.0, 0.46); handle.rotation.z = Math.PI/2; handle.castShadow = true;
            group.add(handle);
            return group;
        }

        function createWardrobe(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0xd4b088, roughness: 0.4 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(2.0, 2.5, 0.9), woodMat);
            body.position.y = 1.25; body.castShadow = true; body.receiveShadow = true;
            group.add(body);
            const door1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2.0, 0.1), doorMat);
            door1.position.set(-0.5, 1.25, 0.46); door1.castShadow = true; door1.receiveShadow = true;
            group.add(door1);
            const door2 = door1.clone(); door2.position.set(0.5, 1.25, 0.46); group.add(door2);
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.15, 6), metalMat);
            handle.position.set(0.5, 1.25, 0.52); handle.rotation.z = Math.PI/2; handle.castShadow = true;
            group.add(handle);
            const handle2 = handle.clone(); handle2.position.set(-0.5, 1.25, 0.52); group.add(handle2);
            return group;
        }

        function createDresser(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
            const drawerMat = new THREE.MeshStandardMaterial({ color: 0xd4b088, roughness: 0.4 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.6), woodMat);
            body.position.y = 0.6; body.castShadow = true; body.receiveShadow = true;
            group.add(body);
            for (let i=0; i<3; i++) {
                const drawer = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.25, 0.1), drawerMat);
                drawer.position.set(0, 0.25 + i*0.3, 0.31); drawer.castShadow = true; drawer.receiveShadow = true;
                group.add(drawer);
                const knob = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6), metalMat);
                knob.position.set(0.4, 0.25 + i*0.3, 0.36); knob.castShadow = true;
                group.add(knob);
            }
            return group;
        }

        function createBed(color) {
            const group = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
            const fabricMat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });

            const base = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.3, 1.8), woodMat);
            base.position.y = 0.15; base.castShadow = true; base.receiveShadow = true;
            group.add(base);
            const mattress = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.3, 1.7), fabricMat);
            mattress.position.y = 0.45; mattress.castShadow = true; mattress.receiveShadow = true;
            group.add(mattress);
            const headboard = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.8, 0.2), woodMat);
            headboard.position.set(0, 0.8, -0.9); headboard.castShadow = true; headboard.receiveShadow = true;
            group.add(headboard);
            return group;
        }

        function createMirror(color) {
            const group = new THREE.Group();
            const frameMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.0, transparent: true, opacity: 0.2 });
            const frame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.1), frameMat);
            frame.position.y = 0.8; frame.castShadow = true; frame.receiveShadow = true;
            group.add(frame);
            const glass = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.4, 0.02), glassMat);
            glass.position.y = 0.8; glass.position.z = 0.06; glass.castShadow = true; glass.receiveShadow = true;
            group.add(glass);
            return group;
        }

        function createClock(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
            const dialMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
            const handMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 });

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16), mat);
            body.rotation.x = 0; body.position.y = 0.8; body.castShadow = true; body.receiveShadow = true;
            group.add(body);
            const dial = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.02, 16), dialMat);
            dial.rotation.x = 0; dial.position.y = 0.8; dial.position.z = 0.06; dial.castShadow = true;
            group.add(dial);
            // –°—Ç—Ä–µ–ª–∫–∏ (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)
            const hour = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.02), handMat);
            hour.position.set(0.1, 0.8, 0.07); hour.castShadow = true;
            group.add(hour);
            const minute = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.2, 0.02), handMat);
            minute.position.set(0.15, 0.8, 0.07); minute.castShadow = true;
            group.add(minute);
            return group;
        }

        // –§–∞–±—Ä–∏–∫–∞ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
        function createItem(type, color, scale = 1) {
            const colorHex = parseInt(color.slice(1), 16);
            let obj;
            switch(type) {
                case 'chester': obj = createChesterChair(colorHex); break;
                case 'eames': obj = createEamesChair(colorHex); break;
                case 'sofa': obj = createSofa(colorHex); break;
                case 'corner_sofa': obj = createCornerSofa(colorHex); break;
                case 'table': obj = createTable(colorHex); break;
                case 'coffee_table': obj = createCoffeeTable(colorHex); break;
                case 'lamp': obj = createLamp(colorHex); break;
                case 'floor_lamp': obj = createFloorLamp(colorHex); break;
                case 'plant': obj = createPlant(colorHex); break;
                case 'palm': obj = createPalm(colorHex); break;
                case 'cabinet': obj = createCabinet(colorHex); break;
                case 'wardrobe': obj = createWardrobe(colorHex); break;
                case 'dresser': obj = createDresser(colorHex); break;
                case 'bed': obj = createBed(colorHex); break;
                case 'mirror': obj = createMirror(colorHex); break;
                case 'clock': obj = createClock(colorHex); break;
                default: obj = createChesterChair(colorHex);
            }
            obj.scale.set(scale, scale, scale);
            return obj;
        }

        // --- –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ (—Ä–∞–º–∫–∞) ---
        function highlightObject(obj, state) {
            scene.children.forEach(child => {
                if (child.isLineSegments && child.userData.isHelper) scene.remove(child);
            });
            if (state && obj) {
                const box = new THREE.BoxHelper(obj, 0xffaa66);
                box.userData.isHelper = true;
                scene.add(box);
            }
        }

        // --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ ---
        function updateStats() {
            document.getElementById('statItems').innerText = placedObjects.length;
        }

        // --- –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ–¥ –º—ã—à—å—é —Å —É—á—ë—Ç–æ–º –ø—Ä–∏–≤—è–∑–∫–∏ –∏ –ø–æ–∏—Å–∫–∞ –æ–±—ä–µ–∫—Ç–∞ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –Ω–∞ –Ω—ë–º ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();

        function getPlacementPosition(event) {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(placedObjects, true);
            if (intersects.length > 0) {
                const hit = intersects[0].object;
                const box = new THREE.Box3().setFromObject(hit);
                const topY = box.max.y;
                const point = intersects[0].point.clone();
                if (snapEnabled) {
                    point.x = Math.round(point.x / 0.5) * 0.5;
                    point.z = Math.round(point.z / 0.5) * 0.5;
                }
                return { point, baseObject: hit, topY };
            }

            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                let point = intersectPoint.clone();
                if (snapEnabled) {
                    point.x = Math.round(point.x / 0.5) * 0.5;
                    point.z = Math.round(point.z / 0.5) * 0.5;
                }
                point.y = 0;
                return { point, baseObject: null, topY: 0 };
            }
            return null;
        }

        // --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –º—ã—à–∏ ---
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('.ui-container')) return;
            if (e.button !== 0) return;

            // –í—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ Alt+–∫–ª–∏–∫
            if (e.altKey) {
                mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(placedObjects, true);
                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    while (obj.parent && !placedObjects.includes(obj)) {
                        obj = obj.parent;
                    }
                    if (placedObjects.includes(obj)) {
                        selectedObject = obj;
                        highlightObject(selectedObject, true);
                    } else {
                        highlightObject(null, false);
                        selectedObject = null;
                    }
                } else {
                    highlightObject(null, false);
                    selectedObject = null;
                }
                return;
            }

            // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ/–≤—Ä–∞—â–µ–Ω–∏–µ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ (–±–µ–∑ Alt)
            if ((currentMode === 'move' || currentMode === 'rotate') && selectedObject) {
                isDragging = true;
                dragStart.set(e.clientX, e.clientY);
                initialObjectPos.copy(selectedObject.position);
                if (currentMode === 'rotate') {
                    initialObjectRot = selectedObject.rotation.y;
                }
                e.preventDefault();
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging || !selectedObject) return;

            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;

            if (currentMode === 'move') {
                if (e.shiftKey) {
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
                    selectedObject.position.y = initialObjectPos.y + dy * 0.02;
                } else {
                    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ (–ø–æ XZ)
                    const deltaX = dx * 0.01 * (camera.position.y / 5);
                    const deltaZ = dy * 0.01 * (camera.position.y / 5);
                    selectedObject.position.x = initialObjectPos.x + deltaX;
                    selectedObject.position.z = initialObjectPos.z + deltaZ;
                }
            } else if (currentMode === 'rotate') {
                selectedObject.rotation.y = initialObjectRot + dx * 0.01;
            }
        });

        renderer.domElement.addEventListener('mouseup', (e) => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('.ui-container')) return;
            if (isDragging) return;
            if (e.altKey) return; // –≤—ã–¥–µ–ª–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –≤ mousedown

            const placement = getPlacementPosition(e);
            if (!placement) return;
            const { point, baseObject, topY } = placement;

            if (currentMode === 'wall') {
                let pos = point.clone();
                pos.y = wallHeight / 2;
                const mat = new THREE.MeshStandardMaterial({ color: parseInt(wallColor.slice(1), 16), roughness: 0.7 });
                const geo = new THREE.BoxGeometry(wallThick, wallHeight, wallLength);
                const wall = new THREE.Mesh(geo, mat);
                wall.position.copy(pos);
                wall.castShadow = true; wall.receiveShadow = true;
                scene.add(wall);
                placedObjects.push(wall);
            } else if (currentMode === 'item') {
                const item = createItem(selectedItemType, itemColor, itemScale);
                item.position.copy(point);
                if (baseObject) {
                    const box = new THREE.Box3().setFromObject(item);
                    const itemHeight = box.max.y - box.min.y;
                    item.position.y = topY + itemHeight / 2;
                } else {
                    item.position.y = itemScale * 0.5;
                }
                item.rotation.y = itemRotate * Math.PI / 180;
                scene.add(item);
                placedObjects.push(item);
                if (selectedItemType === 'plant' || selectedItemType === 'palm') {
                    item.userData.speed = 0.5 + Math.random() * 0.5;
                }
            }
            updateStats();
        });

        // --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ ---
        document.addEventListener('keydown', (e) => {
            if (e.target.closest('input,select')) return;
            if (e.key === 'Delete' && selectedObject) {
                scene.remove(selectedObject);
                placedObjects = placedObjects.filter(obj => obj !== selectedObject);
                highlightObject(null, false);
                selectedObject = null;
                updateStats();
            }
            if (e.ctrlKey && e.key === 'd' && selectedObject) {
                const clone = selectedObject.clone();
                clone.position.x += 1;
                scene.add(clone);
                placedObjects.push(clone);
                selectedObject = clone;
                highlightObject(selectedObject, true);
                updateStats();
            }
        });

        // --- UI –∫–Ω–æ–ø–∫–∏ ---
        document.getElementById('modeWall').addEventListener('click', () => {
            currentMode = 'wall';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeWall').classList.add('active');
            document.getElementById('wallParams').style.display = 'block';
            document.getElementById('itemParams').style.display = 'none';
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –°—Ç–µ–Ω–∞ ‚Äì –∫–ª–∏–∫ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ | Alt+–∫–ª–∏–∫ –≤—ã–¥–µ–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç';
        });
        document.getElementById('modeItem').addEventListener('click', () => {
            currentMode = 'item';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeItem').classList.add('active');
            document.getElementById('wallParams').style.display = 'none';
            document.getElementById('itemParams').style.display = 'block';
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –ü—Ä–µ–¥–º–µ—Ç ‚Äì –∫–ª–∏–∫ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è | Alt+–∫–ª–∏–∫ –≤—ã–¥–µ–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç';
        });
        document.getElementById('modeMove').addEventListener('click', () => {
            currentMode = 'move';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeMove').classList.add('active');
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ ‚Äì –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç (Shift ‚Äì –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑)';
        });
        document.getElementById('modeRotate').addEventListener('click', () => {
            currentMode = 'rotate';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeRotate').classList.add('active');
            document.getElementById('hint').innerText = '–†–µ–∂–∏–º: –ü–æ–≤–æ—Ä–æ—Ç ‚Äì –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ';
        });

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–µ–Ω
        document.getElementById('wallLength').addEventListener('input', (e) => wallLength = parseFloat(e.target.value));
        document.getElementById('wallHeight').addEventListener('input', (e) => wallHeight = parseFloat(e.target.value));
        document.getElementById('wallThick').addEventListener('input', (e) => wallThick = parseFloat(e.target.value));
        document.getElementById('wallColor').addEventListener('input', (e) => wallColor = e.target.value);

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥–º–µ—Ç–æ–≤
        document.getElementById('itemColor').addEventListener('input', (e) => itemColor = e.target.value);
        document.getElementById('itemScale').addEventListener('input', (e) => itemScale = parseFloat(e.target.value));
        document.getElementById('itemRotate').addEventListener('input', (e) => itemRotate = parseFloat(e.target.value));
        document.getElementById('snapGrid').addEventListener('change', (e) => snapEnabled = e.target.checked);

        // –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π
        document.getElementById('saveBtn').addEventListener('click', () => {
            const data = placedObjects.map(obj => ({
                pos: [obj.position.x, obj.position.y, obj.position.z],
                rot: [obj.rotation.x, obj.rotation.y, obj.rotation.z],
                scale: [obj.scale.x, obj.scale.y, obj.scale.z],
                color: obj.material?.color?.getHex()
            }));
            localStorage.setItem('design_scene', JSON.stringify(data));
            alert('–°—Ü–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞');
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            const data = JSON.parse(localStorage.getItem('design_scene'));
            if (!data) return;
            placedObjects.forEach(obj => scene.remove(obj));
            placedObjects = [];
            data.forEach(d => {
                const mat = new THREE.MeshStandardMaterial({ color: d.color || 0xffffff });
                const geo = new THREE.BoxGeometry(1,1,1);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(d.pos[0], d.pos[1], d.pos[2]);
                mesh.rotation.set(d.rot[0], d.rot[1], d.rot[2]);
                mesh.scale.set(d.scale[0], d.scale[1], d.scale[2]);
                mesh.castShadow = true; mesh.receiveShadow = true;
                scene.add(mesh);
                placedObjects.push(mesh);
            });
            updateStats();
        });

        document.getElementById('copyBtn').addEventListener('click', () => {
            if (selectedObject) {
                const clone = selectedObject.clone();
                clone.position.x += 1;
                scene.add(clone);
                placedObjects.push(clone);
                selectedObject = clone;
                highlightObject(selectedObject, true);
                updateStats();
            }
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedObject) {
                scene.remove(selectedObject);
                placedObjects = placedObjects.filter(obj => obj !== selectedObject);
                highlightObject(null, false);
                selectedObject = null;
                updateStats();
            }
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            placedObjects.forEach(obj => scene.remove(obj));
            placedObjects = [];
            highlightObject(null, false);
            selectedObject = null;
            updateStats();
        });

        // --- –ö–∞—Ç–∞–ª–æ–≥ ---
        function loadCatalog() {
            const grid = document.getElementById('catalogGrid');
            catalog.forEach(item => {
                const card = document.createElement('div');
                card.className = 'item-card';
                card.dataset.id = item.id;
                card.innerHTML = `<div class="item-icon">${item.icon}</div><div class="item-name">${item.name}</div>`;
                card.addEventListener('click', () => {
                    document.querySelectorAll('.item-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedItemType = item.id;
                });
                grid.appendChild(card);
            });
            document.querySelector('.item-card')?.classList.add('selected');
        }

        // --- –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞—Å—Ç–µ–Ω–∏–π ---
        function animatePlants() {
            placedObjects.forEach(obj => {
                if (obj.userData && obj.userData.speed) {
                    obj.rotation.z = Math.sin(Date.now() * 0.001 * obj.userData.speed) * 0.02;
                }
            });
        }

        // --- FPS ---
        let lastTime = performance.now();
        let frames = 0;
        function updateFPS() {
            frames++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('statFps').innerText = frames;
                frames = 0;
                lastTime = now;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            animatePlants();
            controls.update();
            renderer.render(scene, camera);
            updateFPS();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.expand();
            window.Telegram.WebApp.ready();
        }

        loadCatalog();
        updateStats();
        animate();
    </script>
</body>
</html>
