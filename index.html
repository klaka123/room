<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>✦ ПРОСТОЙ ДИЗАЙН — ВСЁ РАБОТАЕТ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30,30,30,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 40px;
            display: flex;
            gap: 15px;
            z-index: 100;
            pointer-events: all;
        }
        .btn {
            background: #444;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn.active {
            background: #ffaa66;
            color: black;
        }
        #panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30,30,30,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            width: 260px;
            z-index: 100;
            pointer-events: all;
        }
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        .color-input {
            width: 100%;
            height: 40px;
            margin: 5px 0;
        }
        .hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">Объектов: <span id="objCount">0</span> | Режим: <span id="modeDisplay">Стена</span></div>
    <div id="controls">
        <button class="btn active" id="modeWall">Стена</button>
        <button class="btn" id="modeItem">Предмет</button>
        <button class="btn" id="modeMove">Переместить</button>
        <button class="btn" id="modeRotate">Повернуть</button>
        <button class="btn" id="undo">Отмена</button>
        <button class="btn" id="clear">Очистить</button>
    </div>
    <div id="panel">
        <h3>Параметры</h3>
        <div id="wallParams">
            <label>Длина</label>
            <input type="range" id="wallLength" min="0.5" max="5" step="0.5" value="2" class="slider">
            <label>Высота</label>
            <input type="range" id="wallHeight" min="0.5" max="4" step="0.5" value="2" class="slider">
            <label>Толщина</label>
            <input type="range" id="wallThick" min="0.1" max="1" step="0.1" value="0.3" class="slider">
            <label>Поворот</label>
            <input type="range" id="wallRotate" min="0" max="360" step="5" value="0" class="slider">
            <label>Цвет</label>
            <input type="color" id="wallColor" value="#aaccff" class="color-input">
        </div>
        <div id="itemParams" style="display:none;">
            <label>Модель</label>
            <select id="itemType">
                <option value="chair">Стул</option>
                <option value="table">Стол</option>
                <option value="lamp">Лампа</option>
            </select>
            <label>Цвет</label>
            <input type="color" id="itemColor" value="#c47e5a" class="color-input">
            <label>Масштаб</label>
            <input type="range" id="itemScale" min="1" max="4" step="0.5" value="2" class="slider">
            <label>Поворот</label>
            <input type="range" id="itemRotate" min="0" max="360" step="5" value="0" class="slider">
        </div>
        <div style="margin-top:10px;">
            <button class="btn" id="copyBtn">Копировать (Ctrl+D)</button>
        </div>
        <p style="font-size:12px; margin-top:10px;">G+движение – переместить<br>R+движение – повернуть</p>
    </div>
    <div class="hint" id="hint">Клик – выделить | Двойной клик – создать</div>

    <canvas id="canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Сцена ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x11131f);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 8, 20);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 3;
        controls.maxDistance = 50;
        controls.target.set(0, 2, 0);

        // --- Освещение ---
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(5, 15, 8);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 30;
        sunLight.shadow.camera.left = -10;
        sunLight.shadow.camera.right = 10;
        sunLight.shadow.camera.top = 10;
        sunLight.shadow.camera.bottom = -10;
        scene.add(sunLight);

        const ambient = new THREE.AmbientLight(0x40486c, 0.6);
        scene.add(ambient);

        // --- Пол и сетка ---
        const groundGeo = new THREE.CircleGeometry(100, 32);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a2e3a, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        const gridHelper = new THREE.GridHelper(50, 25, 0xaaaaaa, 0x444444);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // --- Состояние ---
        let placedObjects = [];
        let selectedObject = null;
        let currentMode = 'wall'; // wall, item, move, rotate

        // Параметры
        let wallLength = 2, wallHeight = 2, wallThick = 0.3, wallRotate = 0;
        let wallColor = '#aaccff';
        let itemType = 'chair', itemColor = '#c47e5a', itemScale = 2, itemRotate = 0;

        // Для перемещения/вращения
        let isDragging = false;
        let dragStart = new THREE.Vector2();
        let initialObjectPos = new THREE.Vector3();
        let initialObjectRot = 0;
        let currentAction = null;

        // --- Вспомогательные функции ---
        function updateUI() {
            document.getElementById('objCount').innerText = placedObjects.length;
            document.getElementById('modeDisplay').innerText = 
                currentMode === 'wall' ? 'Стена' :
                currentMode === 'item' ? 'Предмет' :
                currentMode === 'move' ? 'Переместить' : 'Повернуть';
        }

        // --- Детализированные модели (увеличенные) ---

        function createWall() {
            const geo = new THREE.BoxGeometry(wallThick, wallHeight, wallLength);
            const mat = new THREE.MeshStandardMaterial({ color: parseInt(wallColor.slice(1), 16), roughness: 0.7 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createChair() {
            const group = new THREE.Group();
            const scale = itemScale;
            const wood = new THREE.MeshStandardMaterial({ color: parseInt(itemColor.slice(1), 16), roughness: 0.6 });
            const dark = new THREE.MeshStandardMaterial({ color: 0x5a3a2a, roughness: 0.7 });
            const metal = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 0.7 });

            // Ножки (увеличенные)
            const legGeo = new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 0.6 * scale, 8);
            const wheelGeo = new THREE.TorusGeometry(0.1 * scale, 0.03 * scale, 6, 12);
            [-0.5 * scale, 0.5 * scale].forEach(x => {
                [-0.5 * scale, 0.5 * scale].forEach(z => {
                    const leg = new THREE.Mesh(legGeo, dark);
                    leg.position.set(x, 0.3 * scale, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                    const wheel = new THREE.Mesh(wheelGeo, metal);
                    wheel.position.set(x, 0.1 * scale, z);
                    wheel.rotation.x = Math.PI/2;
                    wheel.castShadow = true;
                    group.add(wheel);
                });
            });

            // Сиденье
            const seatBase = new THREE.Mesh(new THREE.BoxGeometry(1.2 * scale, 0.2 * scale, 1.2 * scale), dark);
            seatBase.position.y = 0.6 * scale;
            seatBase.castShadow = true; seatBase.receiveShadow = true;
            group.add(seatBase);

            const cushion = new THREE.Mesh(new THREE.BoxGeometry(1.1 * scale, 0.2 * scale, 1.1 * scale), wood);
            cushion.position.y = 0.8 * scale;
            cushion.castShadow = true; cushion.receiveShadow = true;
            group.add(cushion);

            // Спинка
            const back = new THREE.Mesh(new THREE.BoxGeometry(1.2 * scale, 1.5 * scale, 0.3 * scale), wood);
            back.position.set(0, 1.4 * scale, -0.6 * scale);
            back.castShadow = true; back.receiveShadow = true;
            group.add(back);

            // Подлокотники
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.2 * scale, 0.8 * scale, 1.2 * scale), wood);
            arm.position.set(-0.8 * scale, 1.0 * scale, 0);
            arm.castShadow = true; arm.receiveShadow = true;
            group.add(arm);
            const arm2 = arm.clone(); arm2.position.set(0.8 * scale, 1.0 * scale, 0); group.add(arm2);

            return group;
        }

        function createTable() {
            const group = new THREE.Group();
            const scale = itemScale;
            const wood = new THREE.MeshStandardMaterial({ color: parseInt(itemColor.slice(1), 16), roughness: 0.6 });
            const metal = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });

            const top = new THREE.Mesh(new THREE.BoxGeometry(2.5 * scale, 0.2 * scale, 1.5 * scale), wood);
            top.position.y = 1.2 * scale;
            top.castShadow = true; top.receiveShadow = true;
            group.add(top);

            const legGeo = new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 1.0 * scale, 8);
            [-1.0 * scale, 1.0 * scale].forEach(x => {
                [-0.6 * scale, 0.6 * scale].forEach(z => {
                    const leg = new THREE.Mesh(legGeo, metal);
                    leg.position.set(x, 0.5 * scale, z);
                    leg.castShadow = true; leg.receiveShadow = true;
                    group.add(leg);
                });
            });
            return group;
        }

        function createLamp() {
            const group = new THREE.Group();
            const scale = itemScale;
            const metal = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.3, metalness: 0.8 });
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.6 * scale, 0.7 * scale, 0.3 * scale, 8), metal);
            base.position.y = 0.15 * scale;
            base.castShadow = true; base.receiveShadow = true;
            group.add(base);

            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1 * scale, 0.12 * scale, 3.0 * scale, 8), metal);
            pole.position.y = 1.6 * scale;
            pole.castShadow = true; pole.receiveShadow = true;
            group.add(pole);

            const shade = new THREE.Mesh(new THREE.ConeGeometry(0.7 * scale, 0.8 * scale, 8), new THREE.MeshStandardMaterial({ color: 0xffeedd }));
            shade.position.y = 3.0 * scale;
            shade.castShadow = true; shade.receiveShadow = true;
            group.add(shade);

            const light = new THREE.PointLight(0xffeedd, 1, 8 * scale);
            light.position.y = 2.8 * scale;
            group.add(light);
            return group;
        }

        function createItem() {
            switch(itemType) {
                case 'chair': return createChair();
                case 'table': return createTable();
                case 'lamp': return createLamp();
                default: return createChair();
            }
        }

        // --- Подсветка выделенного ---
        function highlightObject(obj, state) {
            scene.children.forEach(child => {
                if (child.isLineSegments && child.userData.isHelper) scene.remove(child);
            });
            if (state && obj) {
                const box = new THREE.BoxHelper(obj, 0xffaa66);
                box.userData.isHelper = true;
                scene.add(box);
            }
        }

        // --- Получение позиции под мышью ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();

        function getIntersect(event) {
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                return intersectPoint.clone();
            }
            return null;
        }

        // --- Обработчики событий ---
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (e.target.closest('#controls, #panel')) return;

            if (currentMode === 'move' || currentMode === 'rotate') {
                const point = getIntersect(e);
                if (!point) return;
                // Проверяем выделение
                raycaster.ray.intersectPlane(plane, point);
                const intersects = raycaster.intersectObjects(placedObjects, true);
                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    while (obj.parent && !placedObjects.includes(obj)) obj = obj.parent;
                    if (placedObjects.includes(obj)) {
                        selectedObject = obj;
                        highlightObject(selectedObject, true);
                        isDragging = true;
                        dragStart.set(e.clientX, e.clientY);
                        initialObjectPos.copy(selectedObject.position);
                        initialObjectRot = selectedObject.rotation.y;
                        currentAction = currentMode;
                        e.preventDefault();
                    }
                } else {
                    highlightObject(null, false);
                    selectedObject = null;
                }
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging || !selectedObject) return;
            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;

            if (currentAction === 'move') {
                const speed = 0.01;
                selectedObject.position.x = initialObjectPos.x + dx * speed;
                selectedObject.position.z = initialObjectPos.z + dy * speed;
                if (e.shiftKey) {
                    selectedObject.position.y = initialObjectPos.y - dy * speed;
                }
            } else if (currentAction === 'rotate') {
                selectedObject.rotation.y = initialObjectRot + dx * 0.01;
            }
        });

        renderer.domElement.addEventListener('mouseup', (e) => {
            isDragging = false;
            currentAction = null;
        });

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('#controls, #panel')) return;
            const point = getIntersect(e);
            if (!point) return;
            // Выделение
            raycaster.ray.intersectPlane(plane, point);
            const intersects = raycaster.intersectObjects(placedObjects, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !placedObjects.includes(obj)) obj = obj.parent;
                if (placedObjects.includes(obj)) {
                    selectedObject = obj;
                    highlightObject(selectedObject, true);
                } else {
                    highlightObject(null, false);
                    selectedObject = null;
                }
            } else {
                highlightObject(null, false);
                selectedObject = null;
            }
        });

        renderer.domElement.addEventListener('dblclick', (e) => {
            if (e.target.closest('#controls, #panel')) return;
            const point = getIntersect(e);
            if (!point) return;
            // Округляем до сетки (шаг 0.5)
            point.x = Math.round(point.x * 2) / 2;
            point.z = Math.round(point.z * 2) / 2;

            if (currentMode === 'wall') {
                const wall = createWall();
                wall.position.copy(point);
                wall.position.y = wallHeight / 2;
                wall.rotation.y = wallRotate * Math.PI / 180;
                scene.add(wall);
                placedObjects.push(wall);
            } else if (currentMode === 'item') {
                const item = createItem();
                item.position.copy(point);
                item.position.y = 0; // будет поднято в модели
                item.rotation.y = itemRotate * Math.PI / 180;
                scene.add(item);
                placedObjects.push(item);
            }
            updateUI();
        });

        // --- Клавиатура ---
        document.addEventListener('keydown', (e) => {
            if (e.target.closest('input,select')) return;
            if (e.key === 'Delete' && selectedObject) {
                scene.remove(selectedObject);
                placedObjects = placedObjects.filter(obj => obj !== selectedObject);
                highlightObject(null, false);
                selectedObject = null;
                updateUI();
            }
            if (e.ctrlKey && e.key === 'd' && selectedObject) {
                e.preventDefault();
                const clone = selectedObject.clone();
                clone.position.x += 1;
                scene.add(clone);
                placedObjects.push(clone);
                selectedObject = clone;
                highlightObject(selectedObject, true);
                updateUI();
            }
        });

        // --- Кнопки ---
        document.getElementById('modeWall').addEventListener('click', () => {
            currentMode = 'wall';
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeWall').classList.add('active');
            document.getElementById('wallParams').style.display = 'block';
            document.getElementById('itemParams').style.display = 'none';
            document.getElementById('hint').innerText = 'Двойной клик – стена';
            updateUI();
        });
        document.getElementById('modeItem').addEventListener('click', () => {
            currentMode = 'item';
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeItem').classList.add('active');
            document.getElementById('wallParams').style.display = 'none';
            document.getElementById('itemParams').style.display = 'block';
            document.getElementById('hint').innerText = 'Двойной клик – предмет';
            updateUI();
        });
        document.getElementById('modeMove').addEventListener('click', () => {
            currentMode = 'move';
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeMove').classList.add('active');
            document.getElementById('hint').innerText = 'Клик – выделить, G+движение – переместить';
            updateUI();
        });
        document.getElementById('modeRotate').addEventListener('click', () => {
            currentMode = 'rotate';
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('modeRotate').classList.add('active');
            document.getElementById('hint').innerText = 'Клик – выделить, R+движение – повернуть';
            updateUI();
        });
        document.getElementById('undo').addEventListener('click', () => {
            if (placedObjects.length) {
                scene.remove(placedObjects.pop());
                if (selectedObject === placedObjects[placedObjects.length-1]) selectedObject = null;
                highlightObject(null, false);
                updateUI();
            }
        });
        document.getElementById('clear').addEventListener('click', () => {
            placedObjects.forEach(obj => scene.remove(obj));
            placedObjects = [];
            selectedObject = null;
            highlightObject(null, false);
            updateUI();
        });
        document.getElementById('copyBtn').addEventListener('click', () => {
            if (selectedObject) {
                const clone = selectedObject.clone();
                clone.position.x += 1;
                scene.add(clone);
                placedObjects.push(clone);
                selectedObject = clone;
                highlightObject(selectedObject, true);
                updateUI();
            }
        });

        // --- Ползунки ---
        document.getElementById('wallLength').addEventListener('input', (e) => wallLength = parseFloat(e.target.value));
        document.getElementById('wallHeight').addEventListener('input', (e) => wallHeight = parseFloat(e.target.value));
        document.getElementById('wallThick').addEventListener('input', (e) => wallThick = parseFloat(e.target.value));
        document.getElementById('wallRotate').addEventListener('input', (e) => wallRotate = parseFloat(e.target.value));
        document.getElementById('wallColor').addEventListener('input', (e) => wallColor = e.target.value);
        document.getElementById('itemType').addEventListener('change', (e) => itemType = e.target.value);
        document.getElementById('itemColor').addEventListener('input', (e) => itemColor = e.target.value);
        document.getElementById('itemScale').addEventListener('input', (e) => itemScale = parseFloat(e.target.value));
        document.getElementById('itemRotate').addEventListener('input', (e) => itemRotate = parseFloat(e.target.value));

        // --- Анимация ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateUI();
    </script>
</body>
</html>
